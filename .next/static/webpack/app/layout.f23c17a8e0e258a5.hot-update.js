"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/storage.ts":
/*!****************************!*\
  !*** ./src/lib/storage.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListeningTime: function() { return /* binding */ addListeningTime; },\n/* harmony export */   bulkSetSurahStatus: function() { return /* binding */ bulkSetSurahStatus; },\n/* harmony export */   clearAnchorIssues: function() { return /* binding */ clearAnchorIssues; },\n/* harmony export */   deleteCustomMutashabih: function() { return /* binding */ deleteCustomMutashabih; },\n/* harmony export */   exportBackup: function() { return /* binding */ exportBackup; },\n/* harmony export */   findAnchorForRange: function() { return /* binding */ findAnchorForRange; },\n/* harmony export */   getCurrentDayInCycle: function() { return /* binding */ getCurrentDayInCycle; },\n/* harmony export */   getCustomMutashabihat: function() { return /* binding */ getCustomMutashabihat; },\n/* harmony export */   getCycleStart: function() { return /* binding */ getCycleStart; },\n/* harmony export */   getDueNodes: function() { return /* binding */ getDueNodes; },\n/* harmony export */   getErrorsByAnchor: function() { return /* binding */ getErrorsByAnchor; },\n/* harmony export */   getLearnedVersesInPart: function() { return /* binding */ getLearnedVersesInPart; },\n/* harmony export */   getListeningCompletedToday: function() { return /* binding */ getListeningCompletedToday; },\n/* harmony export */   getListeningProgress: function() { return /* binding */ getListeningProgress; },\n/* harmony export */   getListeningStats: function() { return /* binding */ getListeningStats; },\n/* harmony export */   getListeningStatsForSurah: function() { return /* binding */ getListeningStatsForSurah; },\n/* harmony export */   getMemoryNodes: function() { return /* binding */ getMemoryNodes; },\n/* harmony export */   getMindMap: function() { return /* binding */ getMindMap; },\n/* harmony export */   getMindMaps: function() { return /* binding */ getMindMaps; },\n/* harmony export */   getMutashabihatDecisions: function() { return /* binding */ getMutashabihatDecisions; },\n/* harmony export */   getPartMindMap: function() { return /* binding */ getPartMindMap; },\n/* harmony export */   getPartMindMaps: function() { return /* binding */ getPartMindMaps; },\n/* harmony export */   getReviewErrors: function() { return /* binding */ getReviewErrors; },\n/* harmony export */   getSettings: function() { return /* binding */ getSettings; },\n/* harmony export */   getSurahLearnedStatus: function() { return /* binding */ getSurahLearnedStatus; },\n/* harmony export */   getSuspendedAnchors: function() { return /* binding */ getSuspendedAnchors; },\n/* harmony export */   getTotalLearnedVerses: function() { return /* binding */ getTotalLearnedVerses; },\n/* harmony export */   importBackup: function() { return /* binding */ importBackup; },\n/* harmony export */   isSurahSkipped: function() { return /* binding */ isSurahSkipped; },\n/* harmony export */   isVerseLearned: function() { return /* binding */ isVerseLearned; },\n/* harmony export */   markListeningComplete: function() { return /* binding */ markListeningComplete; },\n/* harmony export */   postponeNode: function() { return /* binding */ postponeNode; },\n/* harmony export */   removeReviewError: function() { return /* binding */ removeReviewError; },\n/* harmony export */   resetAllMaturity: function() { return /* binding */ resetAllMaturity; },\n/* harmony export */   resetMutashabihatDecisions: function() { return /* binding */ resetMutashabihatDecisions; },\n/* harmony export */   saveCustomMutashabih: function() { return /* binding */ saveCustomMutashabih; },\n/* harmony export */   saveListeningProgress: function() { return /* binding */ saveListeningProgress; },\n/* harmony export */   saveMemoryNodes: function() { return /* binding */ saveMemoryNodes; },\n/* harmony export */   saveMindMap: function() { return /* binding */ saveMindMap; },\n/* harmony export */   savePartMindMap: function() { return /* binding */ savePartMindMap; },\n/* harmony export */   saveReviewError: function() { return /* binding */ saveReviewError; },\n/* harmony export */   saveSettings: function() { return /* binding */ saveSettings; },\n/* harmony export */   setCycleStart: function() { return /* binding */ setCycleStart; },\n/* harmony export */   setMutashabihatDecision: function() { return /* binding */ setMutashabihatDecision; },\n/* harmony export */   setSurahMaturity: function() { return /* binding */ setSurahMaturity; },\n/* harmony export */   sm2: function() { return /* binding */ sm2; },\n/* harmony export */   syncMemoryNodesWithLearned: function() { return /* binding */ syncMemoryNodesWithLearned; },\n/* harmony export */   toggleSurahLearned: function() { return /* binding */ toggleSurahLearned; },\n/* harmony export */   toggleSurahSkipped: function() { return /* binding */ toggleSurahSkipped; },\n/* harmony export */   toggleVerseLearned: function() { return /* binding */ toggleVerseLearned; },\n/* harmony export */   updateMemoryNode: function() { return /* binding */ updateMemoryNode; },\n/* harmony export */   updateSetting: function() { return /* binding */ updateSetting; }\n/* harmony export */ });\n/* harmony import */ var _quranData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quranData */ \"(app-pages-browser)/./src/lib/quranData.ts\");\n/* harmony import */ var idb_keyval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb-keyval */ \"(app-pages-browser)/./node_modules/idb-keyval/dist/index.js\");\n// ========================================\n// Storage Service - With Part Mindmaps & Review Errors\n// ========================================\n\n\n// ========================================\n// Storage Engine Migration & Helpers\n// ========================================\nconst customStore =  true ? (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.createStore)(\"quran-app-db\", \"quran-app-store\") : 0;\n/**\n * Migration helper to move data from localStorage to IndexedDB once.\n */ async function migrateFromLocalStorage() {\n    if ( false || !customStore) return;\n    const migrationFlag = \"quran-app-migrated-to-idb\";\n    if (localStorage.getItem(migrationFlag)) return;\n    for (const key of Object.values(STORAGE_KEYS)){\n        const value = localStorage.getItem(key);\n        if (value) {\n            try {\n                await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.set)(key, JSON.parse(value), customStore);\n            } catch (e) {\n                console.error(\"Migration failed for key \".concat(key, \":\"), e);\n            }\n        }\n    }\n    localStorage.setItem(migrationFlag, \"true\");\n    console.log(\"Successfully migrated data from localStorage to IndexedDB\");\n}\n// Initial migration trigger\nif (true) {\n    migrateFromLocalStorage();\n}\n/**\n * Global cache to keep synchronous access for existing UI while persisting asynchronously.\n * This ensures the UI remains snappy while data is safely stored in IndexedDB.\n */ const storageCache = {};\nasync function loadIntoCache() {\n    if ( false || !customStore) return;\n    for (const key of Object.values(STORAGE_KEYS)){\n        storageCache[key] = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.get)(key, customStore);\n    }\n}\n// Start loading cache\nif (true) {\n    loadIntoCache();\n}\nfunction getFromCache(key, defaultValue) {\n    if (false) {}\n    const cached = storageCache[key];\n    return cached !== undefined ? cached : defaultValue;\n}\nfunction saveToCacheAndStore(key, value) {\n    storageCache[key] = value;\n    if ( true && customStore) {\n        (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.set)(key, value, customStore).catch((err)=>console.error(\"Failed to persist \".concat(key, \":\"), err));\n    }\n}\nconst STORAGE_KEYS = {\n    SETTINGS: \"quran-app-settings\",\n    MEMORY_NODES: \"quran-app-memory-nodes\",\n    MINDMAPS: \"quran-app-mindmaps\",\n    PART_MINDMAPS: \"quran-app-part-mindmaps\",\n    LISTENING_PROGRESS: \"quran-app-listening-progress\",\n    LISTENING_STATS: \"quran-app-listening-stats\",\n    CYCLE_START: \"quran-app-cycle-start\",\n    LISTENING_COMPLETE: \"quran-app-listening-complete\",\n    REVIEW_ERRORS: \"quran-app-review-errors\",\n    MUTASHABIHAT_DECISIONS: \"quran-app-mutashabihat-decisions\",\n    CUSTOM_MUTASHABIHAT: \"quran-app-custom-mutashabihat\"\n};\nconst DEFAULT_SETTINGS = {\n    completionDays: 30,\n    activePart: 4,\n    learnedVerses: {},\n    skippedSurahs: []\n};\nfunction getSettings() {\n    return getFromCache(STORAGE_KEYS.SETTINGS, DEFAULT_SETTINGS);\n}\nfunction saveSettings(settings) {\n    saveToCacheAndStore(STORAGE_KEYS.SETTINGS, settings);\n}\nfunction updateSetting(key, value) {\n    const settings = getSettings();\n    settings[key] = value;\n    saveSettings(settings);\n}\nfunction isSurahSkipped(surahId) {\n    var _settings_skippedSurahs;\n    const settings = getSettings();\n    return ((_settings_skippedSurahs = settings.skippedSurahs) === null || _settings_skippedSurahs === void 0 ? void 0 : _settings_skippedSurahs.includes(surahId)) || false;\n}\nfunction toggleSurahSkipped(surahId) {\n    const settings = getSettings();\n    const current = new Set(settings.skippedSurahs || []);\n    if (current.has(surahId)) {\n        current.delete(surahId);\n    } else {\n        current.add(surahId);\n        // Also remove any learned data for this surah\n        if (settings.learnedVerses[surahId]) {\n            delete settings.learnedVerses[surahId];\n        }\n        pruneSurahArtifacts(surahId);\n    }\n    settings.skippedSurahs = Array.from(current).sort((a, b)=>a - b);\n    saveSettings(settings);\n}\n// ========================================\n// Learned Verses Helpers\n// ========================================\nfunction isVerseLearned(surahId, ayahId) {\n    var _settings_learnedVerses_surahId;\n    const settings = getSettings();\n    return ((_settings_learnedVerses_surahId = settings.learnedVerses[surahId]) === null || _settings_learnedVerses_surahId === void 0 ? void 0 : _settings_learnedVerses_surahId.includes(ayahId)) || false;\n}\nfunction toggleVerseLearned(surahId, ayahId) {\n    const settings = getSettings();\n    const surahKey = surahId.toString();\n    const current = settings.learnedVerses[surahKey] || [];\n    if (current.includes(ayahId)) {\n        settings.learnedVerses[surahKey] = current.filter((v)=>v !== ayahId);\n        if (settings.learnedVerses[surahKey].length === 0) {\n            delete settings.learnedVerses[surahKey];\n        }\n    } else {\n        settings.learnedVerses[surahKey] = [\n            ...current,\n            ayahId\n        ].sort((a, b)=>a - b);\n    }\n    saveSettings(settings);\n    syncMemoryNodesWithLearned();\n}\nfunction toggleSurahLearned(surahId) {\n    const settings = getSettings();\n    const surah = _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS.find((s)=>s.id === surahId);\n    if (!surah) return;\n    const surahKey = surahId.toString();\n    const current = settings.learnedVerses[surahKey] || [];\n    if (current.length === surah.verseCount) {\n        delete settings.learnedVerses[surahKey];\n    } else {\n        settings.learnedVerses[surahKey] = Array.from({\n            length: surah.verseCount\n        }, (_, i)=>i + 1);\n    }\n    saveSettings(settings);\n    syncMemoryNodesWithLearned();\n}\nfunction getSurahLearnedStatus(surahId) {\n    var _settings_learnedVerses_surahId;\n    const settings = getSettings();\n    const surah = _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS.find((s)=>s.id === surahId);\n    if (!surah) return {\n        learned: 0,\n        total: 0\n    };\n    const learned = ((_settings_learnedVerses_surahId = settings.learnedVerses[surahId]) === null || _settings_learnedVerses_surahId === void 0 ? void 0 : _settings_learnedVerses_surahId.length) || 0;\n    return {\n        learned,\n        total: surah.verseCount\n    };\n}\nfunction getTotalLearnedVerses() {\n    const settings = getSettings();\n    return Object.values(settings.learnedVerses).reduce((sum, verses)=>sum + verses.length, 0);\n}\nfunction getLearnedVersesInPart(part) {\n    const settings = getSettings();\n    const result = [];\n    _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS.filter((s)=>s.part === part).forEach((surah)=>{\n        const verses = settings.learnedVerses[surah.id] || [];\n        verses.forEach((ayahId)=>{\n            result.push({\n                surahId: surah.id,\n                ayahId\n            });\n        });\n    });\n    return result;\n}\nfunction getMemoryNodes() {\n    return getFromCache(STORAGE_KEYS.MEMORY_NODES, []);\n}\nfunction saveMemoryNodes(nodes) {\n    saveToCacheAndStore(STORAGE_KEYS.MEMORY_NODES, nodes);\n}\nfunction getDueNodes() {\n    const today = new Date().toISOString().split(\"T\")[0];\n    const settings = getSettings();\n    const skips = new Set(settings.skippedSurahs || []);\n    const suspended = getSuspendedAnchors();\n    return getMemoryNodes().filter((n)=>n.scheduler.dueDate <= today).filter((n)=>!n.surahId || !skips.has(n.surahId)).filter((n)=>!isNodeSuspended(n, suspended));\n}\nfunction updateMemoryNode(node) {\n    const nodes = getMemoryNodes();\n    const index = nodes.findIndex((n)=>n.id === node.id);\n    if (index >= 0) {\n        nodes[index] = node;\n    } else {\n        nodes.push(node);\n    }\n    saveMemoryNodes(nodes);\n}\nfunction createNewScheduler() {\n    const today = new Date().toISOString().split(\"T\")[0];\n    return {\n        interval: 0,\n        repetition: 0,\n        easeFactor: 2.5,\n        dueDate: today,\n        lastReview: \"\"\n    };\n}\n// Sync memory nodes with learned verses - create nodes for learned verses\nfunction syncMemoryNodesWithLearned() {\n    let forceFullReset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    const settings = getSettings();\n    const nodes = forceFullReset ? [] : getMemoryNodes();\n    // Group verses into segments of 5\n    Object.entries(settings.learnedVerses).forEach((param)=>{\n        let [surahIdStr, verses] = param;\n        const surahId = parseInt(surahIdStr);\n        if (verses.length === 0) return;\n        // Create segments of 5 verses\n        const sortedVerses = [\n            ...verses\n        ].sort((a, b)=>a - b);\n        let segmentStart = sortedVerses[0];\n        let segmentEnd = segmentStart;\n        for(let i = 1; i <= sortedVerses.length; i++){\n            const isContiguous = i < sortedVerses.length && sortedVerses[i] === segmentEnd + 1;\n            const segmentSize = segmentEnd - segmentStart + 1;\n            if (!isContiguous || segmentSize >= 5 || i === sortedVerses.length) {\n                // Create node for this segment if it doesn't exist\n                const nodeId = \"verse-\".concat(surahId, \"-\").concat(segmentStart, \"-\").concat(segmentEnd);\n                const exists = nodes.some((n)=>n.id === nodeId);\n                if (!exists || forceFullReset) {\n                    const newNode = {\n                        id: nodeId,\n                        type: \"verse\",\n                        surahId,\n                        startVerse: segmentStart,\n                        endVerse: segmentEnd,\n                        scheduler: createNewScheduler()\n                    };\n                    if (forceFullReset) {\n                        nodes.push(newNode);\n                    } else if (!exists) {\n                        nodes.push(newNode);\n                    }\n                }\n                if (i < sortedVerses.length) {\n                    segmentStart = sortedVerses[i];\n                    segmentEnd = segmentStart;\n                }\n            } else {\n                segmentEnd = sortedVerses[i];\n            }\n        }\n    });\n    if (forceFullReset) {\n        // Also sync mindmaps\n        const mindmaps = getMindMaps();\n        Object.values(mindmaps).forEach((mm)=>{\n            if (mm.isComplete) {\n                nodes.push({\n                    id: \"mindmap-\".concat(mm.surahId),\n                    type: \"mindmap\",\n                    surahId: mm.surahId,\n                    scheduler: createNewScheduler()\n                });\n            }\n        });\n        // Also sync part mindmaps\n        const partMindmaps = getPartMindMaps();\n        Object.values(partMindmaps).forEach((pmm)=>{\n            if (pmm.isComplete) {\n                nodes.push({\n                    id: \"part-mindmap-\".concat(pmm.partId),\n                    type: \"part_mindmap\",\n                    partId: pmm.partId,\n                    scheduler: createNewScheduler()\n                });\n            }\n        });\n    }\n    saveMemoryNodes(nodes);\n}\n// SM-2 Algorithm\nfunction sm2(grade, state) {\n    let { interval, repetition, easeFactor } = state;\n    if (grade < 3) {\n        repetition = 0;\n        interval = 1;\n    } else {\n        if (repetition === 0) interval = 1;\n        else if (repetition === 1) interval = 6;\n        else interval = Math.round(interval * easeFactor);\n        repetition++;\n    }\n    easeFactor = Math.max(1.3, easeFactor + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)));\n    const dueDate = new Date();\n    dueDate.setDate(dueDate.getDate() + interval);\n    return {\n        interval,\n        repetition,\n        easeFactor: Math.round(easeFactor * 100) / 100,\n        dueDate: dueDate.toISOString().split(\"T\")[0],\n        lastReview: new Date().toISOString().split(\"T\")[0]\n    };\n}\nfunction postponeNode(node) {\n    const tomorrow = new Date();\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    return {\n        ...node,\n        scheduler: {\n            ...node.scheduler,\n            dueDate: tomorrow.toISOString().split(\"T\")[0],\n            lastReview: new Date().toISOString().split(\"T\")[0]\n        }\n    };\n}\nfunction getMindMaps() {\n    return getFromCache(STORAGE_KEYS.MINDMAPS, {});\n}\nfunction getMindMap(surahId) {\n    const maps = getMindMaps();\n    return maps[surahId] || {\n        surahId,\n        imageUrl: null,\n        anchors: [],\n        isComplete: false\n    };\n}\nfunction saveMindMap(mindmap) {\n    const maps = getMindMaps();\n    maps[mindmap.surahId] = mindmap;\n    saveToCacheAndStore(STORAGE_KEYS.MINDMAPS, maps);\n    // Create/update memory node for mindmap if complete\n    if (mindmap.isComplete) {\n        const nodes = getMemoryNodes();\n        const nodeId = \"mindmap-\".concat(mindmap.surahId);\n        const exists = nodes.some((n)=>n.id === nodeId);\n        if (!exists) {\n            nodes.push({\n                id: nodeId,\n                type: \"mindmap\",\n                surahId: mindmap.surahId,\n                scheduler: createNewScheduler()\n            });\n            saveMemoryNodes(nodes);\n        }\n    }\n}\nfunction getPartMindMaps() {\n    return getFromCache(STORAGE_KEYS.PART_MINDMAPS, {});\n}\nfunction getPartMindMap(partId) {\n    const maps = getPartMindMaps();\n    return maps[partId] || {\n        partId,\n        imageUrl: null,\n        description: \"\",\n        isComplete: false\n    };\n}\nfunction savePartMindMap(mindmap) {\n    const maps = getPartMindMaps();\n    maps[mindmap.partId] = mindmap;\n    saveToCacheAndStore(STORAGE_KEYS.PART_MINDMAPS, maps);\n    // Create memory node for part mindmap if complete\n    if (mindmap.isComplete) {\n        const nodes = getMemoryNodes();\n        const nodeId = \"part-mindmap-\".concat(mindmap.partId);\n        const exists = nodes.some((n)=>n.id === nodeId);\n        if (!exists) {\n            nodes.push({\n                id: nodeId,\n                type: \"part_mindmap\",\n                partId: mindmap.partId,\n                scheduler: createNewScheduler()\n            });\n            saveMemoryNodes(nodes);\n        }\n    }\n}\nfunction getListeningProgress(partId) {\n    const map = getFromCache(STORAGE_KEYS.LISTENING_PROGRESS, {});\n    return map[partId] || {\n        partId,\n        currentVerseIndex: 0\n    };\n}\nfunction saveListeningProgress(partId, currentVerseIndex) {\n    const map = getFromCache(STORAGE_KEYS.LISTENING_PROGRESS, {});\n    map[partId] = {\n        partId,\n        currentVerseIndex\n    };\n    saveToCacheAndStore(STORAGE_KEYS.LISTENING_PROGRESS, map);\n}\nfunction getListeningStats() {\n    return getFromCache(STORAGE_KEYS.LISTENING_STATS, {});\n}\nfunction getListeningStatsForSurah(surahId) {\n    const stats = getListeningStats();\n    return stats[surahId] || {\n        surahId,\n        totalMinutes: 0,\n        lastListened: \"\"\n    };\n}\nfunction addListeningTime(surahId, minutes) {\n    const stats = getListeningStats();\n    const current = stats[surahId] || {\n        surahId,\n        totalMinutes: 0,\n        lastListened: \"\"\n    };\n    current.totalMinutes += minutes;\n    current.lastListened = new Date().toISOString();\n    stats[surahId] = current;\n    saveToCacheAndStore(STORAGE_KEYS.LISTENING_STATS, stats);\n}\n// ========================================\n// Listening Complete Tracking\n// ========================================\nfunction getListeningCompletedToday() {\n    const stored = getFromCache(STORAGE_KEYS.LISTENING_COMPLETE, null);\n    if (!stored) return false;\n    const today = new Date().toISOString().split(\"T\")[0];\n    return stored === today;\n}\nfunction markListeningComplete() {\n    const today = new Date().toISOString().split(\"T\")[0];\n    saveToCacheAndStore(STORAGE_KEYS.LISTENING_COMPLETE, today);\n}\nfunction getReviewErrors() {\n    return getFromCache(STORAGE_KEYS.REVIEW_ERRORS, []);\n}\nfunction saveReviewError(error) {\n    const errors = getReviewErrors();\n    errors.push(error);\n    // Keep only last 100 errors\n    const trimmed = errors.slice(-100);\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, trimmed);\n}\nfunction removeReviewError(id) {\n    const errors = getReviewErrors();\n    const remaining = errors.filter((e)=>e.id !== id);\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, remaining);\n}\nfunction getErrorsByAnchor() {\n    const errors = getReviewErrors();\n    const mindmaps = getMindMaps();\n    const anchorCounts = {};\n    errors.filter((e)=>e.grade < 3).forEach((error)=>{\n        if (error.surahId && error.startVerse && error.endVerse) {\n            const mindmap = mindmaps[error.surahId];\n            if (mindmap) {\n                const anchor = mindmap.anchors.find((a)=>a.startVerse <= error.startVerse && a.endVerse >= error.endVerse);\n                if (anchor) {\n                    const key = \"\".concat(error.surahId, \"-\").concat(anchor.id);\n                    if (!anchorCounts[key]) {\n                        anchorCounts[key] = {\n                            label: anchor.label,\n                            count: 0,\n                            surahId: error.surahId,\n                            anchorId: anchor.id,\n                            startVerse: anchor.startVerse,\n                            endVerse: anchor.endVerse\n                        };\n                    }\n                    anchorCounts[key].count++;\n                }\n            }\n        }\n    });\n    return Object.values(anchorCounts).sort((a, b)=>b.count - a.count);\n}\n// ========================================\n// Cycle Management\n// ========================================\nfunction getCycleStart() {\n    let stored = getFromCache(STORAGE_KEYS.CYCLE_START, null);\n    if (!stored) {\n        stored = new Date().toISOString().split(\"T\")[0];\n        saveToCacheAndStore(STORAGE_KEYS.CYCLE_START, stored);\n    }\n    return stored;\n}\nfunction setCycleStart(date) {\n    saveToCacheAndStore(STORAGE_KEYS.CYCLE_START, date);\n}\nfunction getCurrentDayInCycle() {\n    const start = new Date(getCycleStart());\n    const today = new Date();\n    const diff = Math.floor((today.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n    const settings = getSettings();\n    return diff % settings.completionDays;\n}\nfunction setSurahMaturity(surahId, level) {\n    const nodes = getMemoryNodes();\n    const now = new Date();\n    const updatedNodes = nodes.map((node)=>{\n        if (node.surahId !== surahId || node.type !== \"verse\" && node.type !== \"mindmap\") {\n            return node;\n        }\n        let interval = 1;\n        let efactor = 2.5;\n        switch(level){\n            case \"reset\":\n                interval = 1;\n                break;\n            case \"medium\":\n                interval = 14;\n                break;\n            case \"strong\":\n                interval = 30;\n                break;\n            case \"mastered\":\n                interval = 90;\n                break;\n        }\n        // Add jitter: +/- 20%\n        if (level !== \"reset\") {\n            const jitter = interval * 0.2;\n            interval = Math.round(interval + (Math.random() * jitter * 2 - jitter));\n        }\n        const dueDate = new Date(now);\n        dueDate.setDate(dueDate.getDate() + interval);\n        return {\n            ...node,\n            scheduler: {\n                ...node.scheduler,\n                interval,\n                easeFactor: efactor,\n                dueDate: dueDate.toISOString()\n            }\n        };\n    });\n    saveMemoryNodes(updatedNodes);\n}\nfunction resetAllMaturity() {\n    // 1. Clear all memory nodes\n    saveToCacheAndStore(STORAGE_KEYS.MEMORY_NODES, []);\n    // 2. Clear all review errors\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, []);\n    // 3. Regenerate nodes based on currently learned surahs and completed mindmaps\n    syncMemoryNodesWithLearned(true);\n}\nfunction getSuspendedAnchors() {\n    let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n    return getErrorsByAnchor().filter((e)=>e.count >= threshold && e.surahId && e.anchorId).map((e)=>({\n            anchorId: e.anchorId,\n            label: e.label,\n            surahId: e.surahId,\n            count: e.count,\n            startVerse: e.startVerse,\n            endVerse: e.endVerse\n        }));\n}\nfunction clearAnchorIssues(surahId, anchorId) {\n    const remaining = getReviewErrors().filter((err)=>!(err.surahId === surahId && err.anchorId === anchorId));\n    if (false) {}\n    localStorage.setItem(STORAGE_KEYS.REVIEW_ERRORS, JSON.stringify(remaining));\n}\nfunction findAnchorForRange(surahId, startVerse, endVerse) {\n    const mindmap = getMindMap(surahId);\n    if (!startVerse || !endVerse) return undefined;\n    return mindmap.anchors.find((a)=>a.startVerse <= startVerse && a.endVerse >= endVerse);\n}\nfunction getCustomMutashabihat() {\n    return getFromCache(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, []);\n}\nfunction saveCustomMutashabih(mut) {\n    const all = getCustomMutashabihat();\n    const existingIdx = all.findIndex((m)=>m.id === mut.id);\n    if (existingIdx >= 0) {\n        all[existingIdx] = mut;\n    } else {\n        all.push(mut);\n    }\n    saveToCacheAndStore(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, all);\n}\nfunction deleteCustomMutashabih(id) {\n    const all = getCustomMutashabihat().filter((m)=>m.id !== id);\n    saveToCacheAndStore(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, all);\n}\nfunction getMutashabihatDecisions() {\n    return getFromCache(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, {});\n}\nfunction setMutashabihatDecision(absoluteAyah, decision, phraseId) {\n    const decisions = getMutashabihatDecisions();\n    const key = phraseId ? \"\".concat(absoluteAyah, \"-\").concat(phraseId) : absoluteAyah.toString();\n    decisions[key] = decision;\n    saveToCacheAndStore(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, decisions);\n}\nfunction resetMutashabihatDecisions(absoluteAyat) {\n    const decisions = getMutashabihatDecisions();\n    const keysToDelete = Object.keys(decisions).filter((key)=>{\n        const abs = parseInt(key.split(\"-\")[0], 10);\n        return absoluteAyat.includes(abs);\n    });\n    if (keysToDelete.length === 0) return;\n    keysToDelete.forEach((key)=>delete decisions[key]);\n    saveToCacheAndStore(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, decisions);\n}\nfunction bulkSetSurahStatus(surahIds, status) {\n    const settings = getSettings();\n    const allSurahs = _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS;\n    surahIds.forEach((id)=>{\n        const surah = allSurahs.find((s)=>s.id === id);\n        if (!surah) return;\n        const surahKey = id.toString();\n        // Reset state for this surah first\n        delete settings.learnedVerses[surahKey];\n        settings.skippedSurahs = (settings.skippedSurahs || []).filter((sId)=>sId !== id);\n        if (status === \"learned\") {\n            const verseIds = Array.from({\n                length: surah.verseCount\n            }, (_, i)=>i + 1);\n            settings.learnedVerses[surahKey] = verseIds;\n        } else if (status === \"skipped\") {\n            settings.skippedSurahs = [\n                ...settings.skippedSurahs || [],\n                id\n            ];\n            pruneSurahArtifacts(id);\n        }\n    // 'new' status is already handled by the resets above\n    });\n    if (settings.skippedSurahs) {\n        settings.skippedSurahs.sort((a, b)=>a - b);\n    }\n    saveSettings(settings);\n}\nfunction pruneSurahArtifacts(surahId) {\n    // Remove memory nodes for this surah\n    const nodes = getMemoryNodes().filter((n)=>n.surahId !== surahId);\n    saveMemoryNodes(nodes);\n    // Remove surah mindmap\n    const maps = getMindMaps();\n    if (maps[surahId]) {\n        delete maps[surahId];\n        saveToCacheAndStore(STORAGE_KEYS.MINDMAPS, maps);\n    }\n    // Remove review errors\n    const remainingErrors = getReviewErrors().filter((err)=>err.surahId !== surahId);\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, remainingErrors);\n}\nfunction isNodeSuspended(node, issues) {\n    if (!node.surahId) return false;\n    const relatedIssues = issues.filter((i)=>i.surahId === node.surahId);\n    if (relatedIssues.length === 0) return false;\n    if (node.type === \"mindmap\") return true;\n    if (node.type === \"verse\") {\n        const anchor = findAnchorForRange(node.surahId, node.startVerse, node.endVerse);\n        return anchor ? relatedIssues.some((i)=>i.anchorId === anchor.id) : false;\n    }\n    return false;\n}\nfunction exportBackup() {\n    return {\n        settings: getSettings(),\n        memoryNodes: getMemoryNodes(),\n        mindmaps: getMindMaps(),\n        partMindmaps: getPartMindMaps(),\n        listeningStats: getListeningStats(),\n        listeningProgress: getFromCache(STORAGE_KEYS.LISTENING_PROGRESS, {}),\n        reviewErrors: getReviewErrors(),\n        mutashabihatDecisions: getMutashabihatDecisions(),\n        customMutashabihat: getCustomMutashabihat(),\n        cycleStart: getCycleStart(),\n        listeningComplete: getFromCache(STORAGE_KEYS.LISTENING_COMPLETE, null),\n        exportedAt: new Date().toISOString()\n    };\n}\nfunction importBackup(data) {\n    if (data.settings) saveSettings(data.settings);\n    if (data.memoryNodes) saveMemoryNodes(data.memoryNodes);\n    if (data.mindmaps) {\n        saveToCacheAndStore(STORAGE_KEYS.MINDMAPS, data.mindmaps);\n    }\n    if (data.partMindmaps) {\n        saveToCacheAndStore(STORAGE_KEYS.PART_MINDMAPS, data.partMindmaps);\n    }\n    if (data.listeningStats) {\n        saveToCacheAndStore(STORAGE_KEYS.LISTENING_STATS, data.listeningStats);\n    }\n    if (data.listeningProgress) {\n        saveToCacheAndStore(STORAGE_KEYS.LISTENING_PROGRESS, data.listeningProgress);\n    }\n    if (data.reviewErrors) {\n        saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, data.reviewErrors);\n    }\n    if (data.mutashabihatDecisions) {\n        saveToCacheAndStore(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, data.mutashabihatDecisions);\n    }\n    if (data.customMutashabihat) {\n        saveToCacheAndStore(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, data.customMutashabihat);\n    }\n    if (data.cycleStart) setCycleStart(data.cycleStart);\n    if (data.listeningComplete) saveToCacheAndStore(STORAGE_KEYS.LISTENING_COMPLETE, data.listeningComplete);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBMkM7QUFDM0MsdURBQXVEO0FBQ3ZELDJDQUEyQztBQUVOO0FBRWM7QUFFbkQsMkNBQTJDO0FBQzNDLHFDQUFxQztBQUNyQywyQ0FBMkM7QUFFM0MsTUFBTUksY0FBYyxLQUFrQixHQUFjRCx1REFBV0EsQ0FBQyxnQkFBZ0IscUJBQXFCRSxDQUFTQTtBQUU5Rzs7Q0FFQyxHQUNELGVBQWVDO0lBQ1gsSUFBSSxNQUFrQixJQUFlLENBQUNGLGFBQWE7SUFFbkQsTUFBTUcsZ0JBQWdCO0lBQ3RCLElBQUlDLGFBQWFDLE9BQU8sQ0FBQ0YsZ0JBQWdCO0lBRXpDLEtBQUssTUFBTUcsT0FBT0MsT0FBT0MsTUFBTSxDQUFDQyxjQUFlO1FBQzNDLE1BQU1DLFFBQVFOLGFBQWFDLE9BQU8sQ0FBQ0M7UUFDbkMsSUFBSUksT0FBTztZQUNQLElBQUk7Z0JBQ0EsTUFBTVosK0NBQUdBLENBQUNRLEtBQUtLLEtBQUtDLEtBQUssQ0FBQ0YsUUFBUVY7WUFDdEMsRUFBRSxPQUFPYSxHQUFHO2dCQUNSQyxRQUFRQyxLQUFLLENBQUMsNEJBQWdDLE9BQUpULEtBQUksTUFBSU87WUFDdEQ7UUFDSjtJQUNKO0lBRUFULGFBQWFZLE9BQU8sQ0FBQ2IsZUFBZTtJQUNwQ1csUUFBUUcsR0FBRyxDQUFDO0FBQ2hCO0FBRUEsNEJBQTRCO0FBQzVCLElBQUksSUFBa0IsRUFBYTtJQUMvQmY7QUFDSjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1nQixlQUF1QyxDQUFDO0FBRTlDLGVBQWVDO0lBQ1gsSUFBSSxNQUFrQixJQUFlLENBQUNuQixhQUFhO0lBQ25ELEtBQUssTUFBTU0sT0FBT0MsT0FBT0MsTUFBTSxDQUFDQyxjQUFlO1FBQzNDUyxZQUFZLENBQUNaLElBQUksR0FBRyxNQUFNVCwr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QUFLTixxQkFBcUIsRUFBRTtRQUM1QnJOLG9CQUFvQmQsYUFBYTBCLHNCQUFzQixFQUFFK00sS0FBS04scUJBQXFCO0lBQ3ZGO0lBQ0EsSUFBSU0sS0FBS0wsa0JBQWtCLEVBQUU7UUFDekJ0TixvQkFBb0JkLGFBQWEyQixtQkFBbUIsRUFBRThNLEtBQUtMLGtCQUFrQjtJQUNqRjtJQUNBLElBQUlLLEtBQUtKLFVBQVUsRUFBRXJELGNBQWN5RCxLQUFLSixVQUFVO0lBQ2xELElBQUlJLEtBQUtILGlCQUFpQixFQUFFeE4sb0JBQW9CZCxhQUFhd0Isa0JBQWtCLEVBQUVpTixLQUFLSCxpQkFBaUI7QUFDM0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zdG9yYWdlLnRzP2FmZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3RvcmFnZSBTZXJ2aWNlIC0gV2l0aCBQYXJ0IE1pbmRtYXBzICYgUmV2aWV3IEVycm9yc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgeyBTVVJBSFMgfSBmcm9tICcuL3F1cmFuRGF0YSc7XG5pbXBvcnQgeyBRdXJhblBhcnQsIGdldE1hdHVyaXR5VGhyZXNob2xkIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXQsIHNldCwgY3JlYXRlU3RvcmUgfSBmcm9tICdpZGIta2V5dmFsJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3RvcmFnZSBFbmdpbmUgTWlncmF0aW9uICYgSGVscGVyc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBjdXN0b21TdG9yZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gY3JlYXRlU3RvcmUoJ3F1cmFuLWFwcC1kYicsICdxdXJhbi1hcHAtc3RvcmUnKSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBNaWdyYXRpb24gaGVscGVyIHRvIG1vdmUgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSB0byBJbmRleGVkREIgb25jZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWlncmF0ZUZyb21Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFjdXN0b21TdG9yZSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG1pZ3JhdGlvbkZsYWcgPSAncXVyYW4tYXBwLW1pZ3JhdGVkLXRvLWlkYic7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKG1pZ3JhdGlvbkZsYWcpKSByZXR1cm47XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QudmFsdWVzKFNUT1JBR0VfS0VZUykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2V0KGtleSwgSlNPTi5wYXJzZSh2YWx1ZSksIGN1c3RvbVN0b3JlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBNaWdyYXRpb24gZmFpbGVkIGZvciBrZXkgJHtrZXl9OmAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1pZ3JhdGlvbkZsYWcsICd0cnVlJyk7XG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBtaWdyYXRlZCBkYXRhIGZyb20gbG9jYWxTdG9yYWdlIHRvIEluZGV4ZWREQicpO1xufVxuXG4vLyBJbml0aWFsIG1pZ3JhdGlvbiB0cmlnZ2VyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtaWdyYXRlRnJvbUxvY2FsU3RvcmFnZSgpO1xufVxuXG4vKipcbiAqIEdsb2JhbCBjYWNoZSB0byBrZWVwIHN5bmNocm9ub3VzIGFjY2VzcyBmb3IgZXhpc3RpbmcgVUkgd2hpbGUgcGVyc2lzdGluZyBhc3luY2hyb25vdXNseS5cbiAqIFRoaXMgZW5zdXJlcyB0aGUgVUkgcmVtYWlucyBzbmFwcHkgd2hpbGUgZGF0YSBpcyBzYWZlbHkgc3RvcmVkIGluIEluZGV4ZWREQi5cbiAqL1xuY29uc3Qgc3RvcmFnZUNhY2hlOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge307XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbnRvQ2FjaGUoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFjdXN0b21TdG9yZSkgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC52YWx1ZXMoU1RPUkFHRV9LRVlTKSkge1xuICAgICAgICBzdG9yYWdlQ2FjaGVba2V5XSA9IGF3YWl0IGdldChrZXksIGN1c3RvbVN0b3JlKTtcbiAgICB9XG59XG5cbi8vIFN0YXJ0IGxvYWRpbmcgY2FjaGVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvYWRJbnRvQ2FjaGUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJvbUNhY2hlPFQ+KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IFQpOiBUIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgY29uc3QgY2FjaGVkID0gc3RvcmFnZUNhY2hlW2tleV07XG4gICAgcmV0dXJuIGNhY2hlZCAhPT0gdW5kZWZpbmVkID8gY2FjaGVkIDogZGVmYXVsdFZhbHVlO1xufVxuXG5mdW5jdGlvbiBzYXZlVG9DYWNoZUFuZFN0b3JlKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgc3RvcmFnZUNhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgY3VzdG9tU3RvcmUpIHtcbiAgICAgICAgc2V0KGtleSwgdmFsdWUsIGN1c3RvbVN0b3JlKS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBlcnNpc3QgJHtrZXl9OmAsIGVycikpO1xuICAgIH1cbn1cblxuY29uc3QgU1RPUkFHRV9LRVlTID0ge1xuICAgIFNFVFRJTkdTOiAncXVyYW4tYXBwLXNldHRpbmdzJyxcbiAgICBNRU1PUllfTk9ERVM6ICdxdXJhbi1hcHAtbWVtb3J5LW5vZGVzJyxcbiAgICBNSU5ETUFQUzogJ3F1cmFuLWFwcC1taW5kbWFwcycsXG4gICAgUEFSVF9NSU5ETUFQUzogJ3F1cmFuLWFwcC1wYXJ0LW1pbmRtYXBzJyxcbiAgICBMSVNURU5JTkdfUFJPR1JFU1M6ICdxdXJhbi1hcHAtbGlzdGVuaW5nLXByb2dyZXNzJyxcbiAgICBMSVNURU5JTkdfU1RBVFM6ICdxdXJhbi1hcHAtbGlzdGVuaW5nLXN0YXRzJyxcbiAgICBDWUNMRV9TVEFSVDogJ3F1cmFuLWFwcC1jeWNsZS1zdGFydCcsXG4gICAgTElTVEVOSU5HX0NPTVBMRVRFOiAncXVyYW4tYXBwLWxpc3RlbmluZy1jb21wbGV0ZScsXG4gICAgUkVWSUVXX0VSUk9SUzogJ3F1cmFuLWFwcC1yZXZpZXctZXJyb3JzJyxcbiAgICBNVVRBU0hBQklIQVRfREVDSVNJT05TOiAncXVyYW4tYXBwLW11dGFzaGFiaWhhdC1kZWNpc2lvbnMnLFxuICAgIENVU1RPTV9NVVRBU0hBQklIQVQ6ICdxdXJhbi1hcHAtY3VzdG9tLW11dGFzaGFiaWhhdCcsXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXR0aW5nc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwcFNldHRpbmdzIHtcbiAgICBjb21wbGV0aW9uRGF5czogbnVtYmVyO1xuICAgIGFjdGl2ZVBhcnQ6IFF1cmFuUGFydDtcbiAgICBsZWFybmVkVmVyc2VzOiB7IFtzdXJhaElkOiBzdHJpbmddOiBudW1iZXJbXSB9O1xuICAgIHNraXBwZWRTdXJhaHM/OiBudW1iZXJbXTtcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogQXBwU2V0dGluZ3MgPSB7XG4gICAgY29tcGxldGlvbkRheXM6IDMwLFxuICAgIGFjdGl2ZVBhcnQ6IDQsXG4gICAgbGVhcm5lZFZlcnNlczoge30sXG4gICAgc2tpcHBlZFN1cmFoczogW10sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2V0dGluZ3MoKTogQXBwU2V0dGluZ3Mge1xuICAgIHJldHVybiBnZXRGcm9tQ2FjaGUoU1RPUkFHRV9LRVlTLlNFVFRJTkdTLCBERUZBVUxUX1NFVFRJTkdTKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTZXR0aW5ncyhzZXR0aW5nczogQXBwU2V0dGluZ3MpOiB2b2lkIHtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5TRVRUSU5HUywgc2V0dGluZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU2V0dGluZzxLIGV4dGVuZHMga2V5b2YgQXBwU2V0dGluZ3M+KGtleTogSywgdmFsdWU6IEFwcFNldHRpbmdzW0tdKTogdm9pZCB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdXJhaFNraXBwZWQoc3VyYWhJZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIHJldHVybiBzZXR0aW5ncy5za2lwcGVkU3VyYWhzPy5pbmNsdWRlcyhzdXJhaElkKSB8fCBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVN1cmFoU2tpcHBlZChzdXJhaElkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgY29uc3QgY3VycmVudCA9IG5ldyBTZXQoc2V0dGluZ3Muc2tpcHBlZFN1cmFocyB8fCBbXSk7XG4gICAgaWYgKGN1cnJlbnQuaGFzKHN1cmFoSWQpKSB7XG4gICAgICAgIGN1cnJlbnQuZGVsZXRlKHN1cmFoSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuYWRkKHN1cmFoSWQpO1xuICAgICAgICAvLyBBbHNvIHJlbW92ZSBhbnkgbGVhcm5lZCBkYXRhIGZvciB0aGlzIHN1cmFoXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoSWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaElkXTtcbiAgICAgICAgfVxuICAgICAgICBwcnVuZVN1cmFoQXJ0aWZhY3RzKHN1cmFoSWQpO1xuICAgIH1cbiAgICBzZXR0aW5ncy5za2lwcGVkU3VyYWhzID0gQXJyYXkuZnJvbShjdXJyZW50KS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgc2F2ZVNldHRpbmdzKHNldHRpbmdzKTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTGVhcm5lZCBWZXJzZXMgSGVscGVyc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWZXJzZUxlYXJuZWQoc3VyYWhJZDogbnVtYmVyLCBheWFoSWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICByZXR1cm4gc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaElkXT8uaW5jbHVkZXMoYXlhaElkKSB8fCBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVZlcnNlTGVhcm5lZChzdXJhaElkOiBudW1iZXIsIGF5YWhJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IHN1cmFoS2V5ID0gc3VyYWhJZC50b1N0cmluZygpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoS2V5XSB8fCBbXTtcblxuICAgIGlmIChjdXJyZW50LmluY2x1ZGVzKGF5YWhJZCkpIHtcbiAgICAgICAgc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV0gPSBjdXJyZW50LmZpbHRlcih2ID0+IHYgIT09IGF5YWhJZCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoS2V5XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoS2V5XTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldID0gWy4uLmN1cnJlbnQsIGF5YWhJZF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cblxuICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgc3luY01lbW9yeU5vZGVzV2l0aExlYXJuZWQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVN1cmFoTGVhcm5lZChzdXJhaElkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgY29uc3Qgc3VyYWggPSBTVVJBSFMuZmluZChzID0+IHMuaWQgPT09IHN1cmFoSWQpO1xuICAgIGlmICghc3VyYWgpIHJldHVybjtcblxuICAgIGNvbnN0IHN1cmFoS2V5ID0gc3VyYWhJZC50b1N0cmluZygpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoS2V5XSB8fCBbXTtcblxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gc3VyYWgudmVyc2VDb3VudCkge1xuICAgICAgICBkZWxldGUgc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzdXJhaC52ZXJzZUNvdW50IH0sIChfLCBpKSA9PiBpICsgMSk7XG4gICAgfVxuXG4gICAgc2F2ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBzeW5jTWVtb3J5Tm9kZXNXaXRoTGVhcm5lZCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VyYWhMZWFybmVkU3RhdHVzKHN1cmFoSWQ6IG51bWJlcik6IHsgbGVhcm5lZDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBzdXJhaCA9IFNVUkFIUy5maW5kKHMgPT4gcy5pZCA9PT0gc3VyYWhJZCk7XG4gICAgaWYgKCFzdXJhaCkgcmV0dXJuIHsgbGVhcm5lZDogMCwgdG90YWw6IDAgfTtcblxuICAgIGNvbnN0IGxlYXJuZWQgPSBzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoSWRdPy5sZW5ndGggfHwgMDtcbiAgICByZXR1cm4geyBsZWFybmVkLCB0b3RhbDogc3VyYWgudmVyc2VDb3VudCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG90YWxMZWFybmVkVmVyc2VzKCk6IG51bWJlciB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNldHRpbmdzLmxlYXJuZWRWZXJzZXMpLnJlZHVjZSgoc3VtLCB2ZXJzZXMpID0+IHN1bSArIHZlcnNlcy5sZW5ndGgsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVhcm5lZFZlcnNlc0luUGFydChwYXJ0OiBRdXJhblBhcnQpOiB7IHN1cmFoSWQ6IG51bWJlcjsgYXlhaElkOiBudW1iZXIgfVtdIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgY29uc3QgcmVzdWx0OiB7IHN1cmFoSWQ6IG51bWJlcjsgYXlhaElkOiBudW1iZXIgfVtdID0gW107XG5cbiAgICBTVVJBSFMuZmlsdGVyKHMgPT4gcy5wYXJ0ID09PSBwYXJ0KS5mb3JFYWNoKHN1cmFoID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2VzID0gc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaC5pZF0gfHwgW107XG4gICAgICAgIHZlcnNlcy5mb3JFYWNoKGF5YWhJZCA9PiB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN1cmFoSWQ6IHN1cmFoLmlkLCBheWFoSWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTWVtb3J5IE5vZGVzIChTTS0yKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIFNNMlN0YXRlIHtcbiAgICBpbnRlcnZhbDogbnVtYmVyO1xuICAgIHJlcGV0aXRpb246IG51bWJlcjtcbiAgICBlYXNlRmFjdG9yOiBudW1iZXI7XG4gICAgZHVlRGF0ZTogc3RyaW5nO1xuICAgIGxhc3RSZXZpZXc6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlOb2RlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6ICd2ZXJzZScgfCAnbWluZG1hcCcgfCAncGFydF9taW5kbWFwJztcbiAgICBzdXJhaElkPzogbnVtYmVyO1xuICAgIHBhcnRJZD86IFF1cmFuUGFydDtcbiAgICBzdGFydFZlcnNlPzogbnVtYmVyO1xuICAgIGVuZFZlcnNlPzogbnVtYmVyO1xuICAgIHNjaGVkdWxlcjogU00yU3RhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZW1vcnlOb2RlcygpOiBNZW1vcnlOb2RlW10ge1xuICAgIHJldHVybiBnZXRGcm9tQ2FjaGUoU1RPUkFHRV9LRVlTLk1FTU9SWV9OT0RFUywgW10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZU1lbW9yeU5vZGVzKG5vZGVzOiBNZW1vcnlOb2RlW10pOiB2b2lkIHtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5NRU1PUllfTk9ERVMsIG5vZGVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldER1ZU5vZGVzKCk6IE1lbW9yeU5vZGVbXSB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgY29uc3Qgc2tpcHMgPSBuZXcgU2V0KHNldHRpbmdzLnNraXBwZWRTdXJhaHMgfHwgW10pO1xuICAgIGNvbnN0IHN1c3BlbmRlZCA9IGdldFN1c3BlbmRlZEFuY2hvcnMoKTtcblxuICAgIHJldHVybiBnZXRNZW1vcnlOb2RlcygpXG4gICAgICAgIC5maWx0ZXIobiA9PiBuLnNjaGVkdWxlci5kdWVEYXRlIDw9IHRvZGF5KVxuICAgICAgICAuZmlsdGVyKG4gPT4gIW4uc3VyYWhJZCB8fCAhc2tpcHMuaGFzKG4uc3VyYWhJZCkpXG4gICAgICAgIC5maWx0ZXIobiA9PiAhaXNOb2RlU3VzcGVuZGVkKG4sIHN1c3BlbmRlZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVtb3J5Tm9kZShub2RlOiBNZW1vcnlOb2RlKTogdm9pZCB7XG4gICAgY29uc3Qgbm9kZXMgPSBnZXRNZW1vcnlOb2RlcygpO1xuICAgIGNvbnN0IGluZGV4ID0gbm9kZXMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm9kZS5pZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbm9kZXNbaW5kZXhdID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzYXZlTWVtb3J5Tm9kZXMobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXdTY2hlZHVsZXIoKTogU00yU3RhdGUge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJ2YWw6IDAsXG4gICAgICAgIHJlcGV0aXRpb246IDAsXG4gICAgICAgIGVhc2VGYWN0b3I6IDIuNSxcbiAgICAgICAgZHVlRGF0ZTogdG9kYXksXG4gICAgICAgIGxhc3RSZXZpZXc6ICcnLFxuICAgIH07XG59XG5cbi8vIFN5bmMgbWVtb3J5IG5vZGVzIHdpdGggbGVhcm5lZCB2ZXJzZXMgLSBjcmVhdGUgbm9kZXMgZm9yIGxlYXJuZWQgdmVyc2VzXG5leHBvcnQgZnVuY3Rpb24gc3luY01lbW9yeU5vZGVzV2l0aExlYXJuZWQoZm9yY2VGdWxsUmVzZXQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBub2RlcyA9IGZvcmNlRnVsbFJlc2V0ID8gW10gOiBnZXRNZW1vcnlOb2RlcygpO1xuXG4gICAgLy8gR3JvdXAgdmVyc2VzIGludG8gc2VnbWVudHMgb2YgNVxuICAgIE9iamVjdC5lbnRyaWVzKHNldHRpbmdzLmxlYXJuZWRWZXJzZXMpLmZvckVhY2goKFtzdXJhaElkU3RyLCB2ZXJzZXNdKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1cmFoSWQgPSBwYXJzZUludChzdXJhaElkU3RyKTtcbiAgICAgICAgaWYgKHZlcnNlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICAvLyBDcmVhdGUgc2VnbWVudHMgb2YgNSB2ZXJzZXNcbiAgICAgICAgY29uc3Qgc29ydGVkVmVyc2VzID0gWy4uLnZlcnNlc10uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBsZXQgc2VnbWVudFN0YXJ0ID0gc29ydGVkVmVyc2VzWzBdO1xuICAgICAgICBsZXQgc2VnbWVudEVuZCA9IHNlZ21lbnRTdGFydDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzb3J0ZWRWZXJzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29udGlndW91cyA9IGkgPCBzb3J0ZWRWZXJzZXMubGVuZ3RoICYmIHNvcnRlZFZlcnNlc1tpXSA9PT0gc2VnbWVudEVuZCArIDE7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50U2l6ZSA9IHNlZ21lbnRFbmQgLSBzZWdtZW50U3RhcnQgKyAxO1xuXG4gICAgICAgICAgICBpZiAoIWlzQ29udGlndW91cyB8fCBzZWdtZW50U2l6ZSA+PSA1IHx8IGkgPT09IHNvcnRlZFZlcnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbm9kZSBmb3IgdGhpcyBzZWdtZW50IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlSWQgPSBgdmVyc2UtJHtzdXJhaElkfS0ke3NlZ21lbnRTdGFydH0tJHtzZWdtZW50RW5kfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gbm9kZXMuc29tZShuID0+IG4uaWQgPT09IG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMgfHwgZm9yY2VGdWxsUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZTogTWVtb3J5Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VyYWhJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VmVyc2U6IHNlZ21lbnRTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFZlcnNlOiBzZWdtZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyOiBjcmVhdGVOZXdTY2hlZHVsZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VGdWxsUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgc29ydGVkVmVyc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50U3RhcnQgPSBzb3J0ZWRWZXJzZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRFbmQgPSBzZWdtZW50U3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50RW5kID0gc29ydGVkVmVyc2VzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZm9yY2VGdWxsUmVzZXQpIHtcbiAgICAgICAgLy8gQWxzbyBzeW5jIG1pbmRtYXBzXG4gICAgICAgIGNvbnN0IG1pbmRtYXBzID0gZ2V0TWluZE1hcHMoKTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhtaW5kbWFwcykuZm9yRWFjaChtbSA9PiB7XG4gICAgICAgICAgICBpZiAobW0uaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogYG1pbmRtYXAtJHttbS5zdXJhaElkfWAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtaW5kbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgc3VyYWhJZDogbW0uc3VyYWhJZCxcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyOiBjcmVhdGVOZXdTY2hlZHVsZXIoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWxzbyBzeW5jIHBhcnQgbWluZG1hcHNcbiAgICAgICAgY29uc3QgcGFydE1pbmRtYXBzID0gZ2V0UGFydE1pbmRNYXBzKCk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMocGFydE1pbmRtYXBzKS5mb3JFYWNoKHBtbSA9PiB7XG4gICAgICAgICAgICBpZiAocG1tLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBwYXJ0LW1pbmRtYXAtJHtwbW0ucGFydElkfWAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJ0X21pbmRtYXAnLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SWQ6IHBtbS5wYXJ0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcjogY3JlYXRlTmV3U2NoZWR1bGVyKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNhdmVNZW1vcnlOb2Rlcyhub2Rlcyk7XG59XG5cbi8vIFNNLTIgQWxnb3JpdGhtXG5leHBvcnQgZnVuY3Rpb24gc20yKGdyYWRlOiBudW1iZXIsIHN0YXRlOiBTTTJTdGF0ZSk6IFNNMlN0YXRlIHtcbiAgICBsZXQgeyBpbnRlcnZhbCwgcmVwZXRpdGlvbiwgZWFzZUZhY3RvciB9ID0gc3RhdGU7XG5cbiAgICBpZiAoZ3JhZGUgPCAzKSB7XG4gICAgICAgIHJlcGV0aXRpb24gPSAwO1xuICAgICAgICBpbnRlcnZhbCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcGV0aXRpb24gPT09IDApIGludGVydmFsID0gMTtcbiAgICAgICAgZWxzZSBpZiAocmVwZXRpdGlvbiA9PT0gMSkgaW50ZXJ2YWwgPSA2O1xuICAgICAgICBlbHNlIGludGVydmFsID0gTWF0aC5yb3VuZChpbnRlcnZhbCAqIGVhc2VGYWN0b3IpO1xuICAgICAgICByZXBldGl0aW9uKys7XG4gICAgfVxuXG4gICAgZWFzZUZhY3RvciA9IE1hdGgubWF4KDEuMywgZWFzZUZhY3RvciArICgwLjEgLSAoNSAtIGdyYWRlKSAqICgwLjA4ICsgKDUgLSBncmFkZSkgKiAwLjAyKSkpO1xuXG4gICAgY29uc3QgZHVlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgZHVlRGF0ZS5zZXREYXRlKGR1ZURhdGUuZ2V0RGF0ZSgpICsgaW50ZXJ2YWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIHJlcGV0aXRpb24sXG4gICAgICAgIGVhc2VGYWN0b3I6IE1hdGgucm91bmQoZWFzZUZhY3RvciAqIDEwMCkgLyAxMDAsXG4gICAgICAgIGR1ZURhdGU6IGR1ZURhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICBsYXN0UmV2aWV3OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdHBvbmVOb2RlKG5vZGU6IE1lbW9yeU5vZGUpOiBNZW1vcnlOb2RlIHtcbiAgICBjb25zdCB0b21vcnJvdyA9IG5ldyBEYXRlKCk7XG4gICAgdG9tb3Jyb3cuc2V0RGF0ZSh0b21vcnJvdy5nZXREYXRlKCkgKyAxKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgICAgIC4uLm5vZGUuc2NoZWR1bGVyLFxuICAgICAgICAgICAgZHVlRGF0ZTogdG9tb3Jyb3cudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICAgICAgbGFzdFJldmlldzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNaW5kbWFwcyAocGVyIHN1cmFoKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuY2hvciB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBzdGFydFZlcnNlOiBudW1iZXI7XG4gICAgZW5kVmVyc2U6IG51bWJlcjtcbiAgICBsYWJlbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1pbmRNYXAge1xuICAgIHN1cmFoSWQ6IG51bWJlcjtcbiAgICBpbWFnZVVybDogc3RyaW5nIHwgbnVsbDtcbiAgICBhbmNob3JzOiBBbmNob3JbXTtcbiAgICBpc0NvbXBsZXRlOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluZE1hcHMoKTogeyBbc3VyYWhJZDogc3RyaW5nXTogTWluZE1hcCB9IHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5NSU5ETUFQUywge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluZE1hcChzdXJhaElkOiBudW1iZXIpOiBNaW5kTWFwIHtcbiAgICBjb25zdCBtYXBzID0gZ2V0TWluZE1hcHMoKTtcbiAgICByZXR1cm4gbWFwc1tzdXJhaElkXSB8fCB7IHN1cmFoSWQsIGltYWdlVXJsOiBudWxsLCBhbmNob3JzOiBbXSwgaXNDb21wbGV0ZTogZmFsc2UgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVNaW5kTWFwKG1pbmRtYXA6IE1pbmRNYXApOiB2b2lkIHtcbiAgICBjb25zdCBtYXBzID0gZ2V0TWluZE1hcHMoKTtcbiAgICBtYXBzW21pbmRtYXAuc3VyYWhJZF0gPSBtaW5kbWFwO1xuICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1JTkRNQVBTLCBtYXBzKTtcblxuICAgIC8vIENyZWF0ZS91cGRhdGUgbWVtb3J5IG5vZGUgZm9yIG1pbmRtYXAgaWYgY29tcGxldGVcbiAgICBpZiAobWluZG1hcC5pc0NvbXBsZXRlKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ2V0TWVtb3J5Tm9kZXMoKTtcbiAgICAgICAgY29uc3Qgbm9kZUlkID0gYG1pbmRtYXAtJHttaW5kbWFwLnN1cmFoSWR9YDtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gbm9kZXMuc29tZShuID0+IG4uaWQgPT09IG5vZGVJZCk7XG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdtaW5kbWFwJyxcbiAgICAgICAgICAgICAgICBzdXJhaElkOiBtaW5kbWFwLnN1cmFoSWQsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyOiBjcmVhdGVOZXdTY2hlZHVsZXIoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2F2ZU1lbW9yeU5vZGVzKG5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUGFydCBNaW5kbWFwcyAoaW50ZXItc3VyYWggY29ubmVjdGlvbnMpXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFydE1pbmRNYXAge1xuICAgIHBhcnRJZDogUXVyYW5QYXJ0O1xuICAgIGltYWdlVXJsOiBzdHJpbmcgfCBudWxsO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgaXNDb21wbGV0ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnRNaW5kTWFwcygpOiB7IFtwYXJ0SWQ6IHN0cmluZ106IFBhcnRNaW5kTWFwIH0ge1xuICAgIHJldHVybiBnZXRGcm9tQ2FjaGUoU1RPUkFHRV9LRVlTLlBBUlRfTUlORE1BUFMsIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnRNaW5kTWFwKHBhcnRJZDogUXVyYW5QYXJ0KTogUGFydE1pbmRNYXAge1xuICAgIGNvbnN0IG1hcHMgPSBnZXRQYXJ0TWluZE1hcHMoKTtcbiAgICByZXR1cm4gbWFwc1twYXJ0SWRdIHx8IHsgcGFydElkLCBpbWFnZVVybDogbnVsbCwgZGVzY3JpcHRpb246ICcnLCBpc0NvbXBsZXRlOiBmYWxzZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVBhcnRNaW5kTWFwKG1pbmRtYXA6IFBhcnRNaW5kTWFwKTogdm9pZCB7XG4gICAgY29uc3QgbWFwcyA9IGdldFBhcnRNaW5kTWFwcygpO1xuICAgIG1hcHNbbWluZG1hcC5wYXJ0SWRdID0gbWluZG1hcDtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5QQVJUX01JTkRNQVBTLCBtYXBzKTtcblxuICAgIC8vIENyZWF0ZSBtZW1vcnkgbm9kZSBmb3IgcGFydCBtaW5kbWFwIGlmIGNvbXBsZXRlXG4gICAgaWYgKG1pbmRtYXAuaXNDb21wbGV0ZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IGdldE1lbW9yeU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IGBwYXJ0LW1pbmRtYXAtJHttaW5kbWFwLnBhcnRJZH1gO1xuICAgICAgICBjb25zdCBleGlzdHMgPSBub2Rlcy5zb21lKG4gPT4gbi5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhcnRfbWluZG1hcCcsXG4gICAgICAgICAgICAgICAgcGFydElkOiBtaW5kbWFwLnBhcnRJZCxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXI6IGNyZWF0ZU5ld1NjaGVkdWxlcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzYXZlTWVtb3J5Tm9kZXMobm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMaXN0ZW5pbmcgU3RhdHNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5pbmdTdGF0cyB7XG4gICAgc3VyYWhJZDogbnVtYmVyO1xuICAgIHRvdGFsTWludXRlczogbnVtYmVyO1xuICAgIGxhc3RMaXN0ZW5lZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RlbmluZ1Byb2dyZXNzIHtcbiAgICBwYXJ0SWQ6IFF1cmFuUGFydDtcbiAgICBjdXJyZW50VmVyc2VJbmRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdGVuaW5nUHJvZ3Jlc3MocGFydElkOiBRdXJhblBhcnQpOiBMaXN0ZW5pbmdQcm9ncmVzcyB7XG4gICAgY29uc3QgbWFwID0gZ2V0RnJvbUNhY2hlPFJlY29yZDxzdHJpbmcsIExpc3RlbmluZ1Byb2dyZXNzPj4oU1RPUkFHRV9LRVlTLkxJU1RFTklOR19QUk9HUkVTUywge30pO1xuICAgIHJldHVybiBtYXBbcGFydElkXSB8fCB7IHBhcnRJZCwgY3VycmVudFZlcnNlSW5kZXg6IDAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVMaXN0ZW5pbmdQcm9ncmVzcyhwYXJ0SWQ6IFF1cmFuUGFydCwgY3VycmVudFZlcnNlSW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IG1hcCA9IGdldEZyb21DYWNoZTxSZWNvcmQ8c3RyaW5nLCBMaXN0ZW5pbmdQcm9ncmVzcz4+KFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfUFJPR1JFU1MsIHt9KTtcbiAgICBtYXBbcGFydElkXSA9IHsgcGFydElkLCBjdXJyZW50VmVyc2VJbmRleCB9O1xuICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLkxJU1RFTklOR19QUk9HUkVTUywgbWFwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExpc3RlbmluZ1N0YXRzKCk6IHsgW3N1cmFoSWQ6IHN0cmluZ106IExpc3RlbmluZ1N0YXRzIH0ge1xuICAgIHJldHVybiBnZXRGcm9tQ2FjaGUoU1RPUkFHRV9LRVlTLkxJU1RFTklOR19TVEFUUywge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdGVuaW5nU3RhdHNGb3JTdXJhaChzdXJhaElkOiBudW1iZXIpOiBMaXN0ZW5pbmdTdGF0cyB7XG4gICAgY29uc3Qgc3RhdHMgPSBnZXRMaXN0ZW5pbmdTdGF0cygpO1xuICAgIHJldHVybiBzdGF0c1tzdXJhaElkXSB8fCB7IHN1cmFoSWQsIHRvdGFsTWludXRlczogMCwgbGFzdExpc3RlbmVkOiAnJyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGlzdGVuaW5nVGltZShzdXJhaElkOiBudW1iZXIsIG1pbnV0ZXM6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHN0YXRzID0gZ2V0TGlzdGVuaW5nU3RhdHMoKTtcbiAgICBjb25zdCBjdXJyZW50ID0gc3RhdHNbc3VyYWhJZF0gfHwgeyBzdXJhaElkLCB0b3RhbE1pbnV0ZXM6IDAsIGxhc3RMaXN0ZW5lZDogJycgfTtcbiAgICBjdXJyZW50LnRvdGFsTWludXRlcyArPSBtaW51dGVzO1xuICAgIGN1cnJlbnQubGFzdExpc3RlbmVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIHN0YXRzW3N1cmFoSWRdID0gY3VycmVudDtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfU1RBVFMsIHN0YXRzKTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTGlzdGVuaW5nIENvbXBsZXRlIFRyYWNraW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXN0ZW5pbmdDb21wbGV0ZWRUb2RheSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdG9yZWQgPSBnZXRGcm9tQ2FjaGU8c3RyaW5nIHwgbnVsbD4oU1RPUkFHRV9LRVlTLkxJU1RFTklOR19DT01QTEVURSwgbnVsbCk7XG4gICAgaWYgKCFzdG9yZWQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgIHJldHVybiBzdG9yZWQgPT09IHRvZGF5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya0xpc3RlbmluZ0NvbXBsZXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTElTVEVOSU5HX0NPTVBMRVRFLCB0b2RheSk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFJldmlldyBFcnJvcnMgVHJhY2tpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBSZXZpZXdFcnJvciB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IHN0cmluZztcbiAgICBub2RlSWQ6IHN0cmluZztcbiAgICBub2RlVHlwZTogJ3ZlcnNlJyB8ICdtaW5kbWFwJyB8ICdwYXJ0X21pbmRtYXAnO1xuICAgIHN1cmFoSWQ/OiBudW1iZXI7XG4gICAgcGFydElkPzogUXVyYW5QYXJ0O1xuICAgIHN0YXJ0VmVyc2U/OiBudW1iZXI7XG4gICAgZW5kVmVyc2U/OiBudW1iZXI7XG4gICAgZ3JhZGU6IG51bWJlcjtcbiAgICBhbmNob3JMYWJlbD86IHN0cmluZztcbiAgICBhbmNob3JJZD86IHN0cmluZztcbiAgICBhYnNvbHV0ZUF5YWg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXZpZXdFcnJvcnMoKTogUmV2aWV3RXJyb3JbXSB7XG4gICAgcmV0dXJuIGdldEZyb21DYWNoZShTVE9SQUdFX0tFWVMuUkVWSUVXX0VSUk9SUywgW10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJldmlld0Vycm9yKGVycm9yOiBSZXZpZXdFcnJvcik6IHZvaWQge1xuICAgIGNvbnN0IGVycm9ycyA9IGdldFJldmlld0Vycm9ycygpO1xuICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAvLyBLZWVwIG9ubHkgbGFzdCAxMDAgZXJyb3JzXG4gICAgY29uc3QgdHJpbW1lZCA9IGVycm9ycy5zbGljZSgtMTAwKTtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5SRVZJRVdfRVJST1JTLCB0cmltbWVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVJldmlld0Vycm9yKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBlcnJvcnMgPSBnZXRSZXZpZXdFcnJvcnMoKTtcbiAgICBjb25zdCByZW1haW5pbmcgPSBlcnJvcnMuZmlsdGVyKGUgPT4gZS5pZCAhPT0gaWQpO1xuICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLlJFVklFV19FUlJPUlMsIHJlbWFpbmluZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvcnNCeUFuY2hvcigpOiB7IGxhYmVsOiBzdHJpbmc7IGNvdW50OiBudW1iZXI7IHN1cmFoSWQ/OiBudW1iZXI7IGFuY2hvcklkPzogc3RyaW5nOyBzdGFydFZlcnNlPzogbnVtYmVyOyBlbmRWZXJzZT86IG51bWJlciB9W10ge1xuICAgIGNvbnN0IGVycm9ycyA9IGdldFJldmlld0Vycm9ycygpO1xuICAgIGNvbnN0IG1pbmRtYXBzID0gZ2V0TWluZE1hcHMoKTtcbiAgICBjb25zdCBhbmNob3JDb3VudHM6IHsgW2tleTogc3RyaW5nXTogeyBsYWJlbDogc3RyaW5nOyBjb3VudDogbnVtYmVyOyBzdXJhaElkPzogbnVtYmVyOyBhbmNob3JJZD86IHN0cmluZzsgc3RhcnRWZXJzZT86IG51bWJlcjsgZW5kVmVyc2U/OiBudW1iZXIgfSB9ID0ge307XG5cbiAgICBlcnJvcnMuZmlsdGVyKGUgPT4gZS5ncmFkZSA8IDMpLmZvckVhY2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3Iuc3VyYWhJZCAmJiBlcnJvci5zdGFydFZlcnNlICYmIGVycm9yLmVuZFZlcnNlKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5kbWFwID0gbWluZG1hcHNbZXJyb3Iuc3VyYWhJZF07XG4gICAgICAgICAgICBpZiAobWluZG1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG1pbmRtYXAuYW5jaG9ycy5maW5kKGEgPT5cbiAgICAgICAgICAgICAgICAgICAgYS5zdGFydFZlcnNlIDw9IGVycm9yLnN0YXJ0VmVyc2UhICYmIGEuZW5kVmVyc2UgPj0gZXJyb3IuZW5kVmVyc2UhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2Vycm9yLnN1cmFoSWR9LSR7YW5jaG9yLmlkfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5jaG9yQ291bnRzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckNvdW50c1trZXldID0geyBsYWJlbDogYW5jaG9yLmxhYmVsLCBjb3VudDogMCwgc3VyYWhJZDogZXJyb3Iuc3VyYWhJZCwgYW5jaG9ySWQ6IGFuY2hvci5pZCwgc3RhcnRWZXJzZTogYW5jaG9yLnN0YXJ0VmVyc2UsIGVuZFZlcnNlOiBhbmNob3IuZW5kVmVyc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbmNob3JDb3VudHNba2V5XS5jb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYW5jaG9yQ291bnRzKS5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudCk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEN5Y2xlIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN5Y2xlU3RhcnQoKTogc3RyaW5nIHtcbiAgICBsZXQgc3RvcmVkID0gZ2V0RnJvbUNhY2hlPHN0cmluZyB8IG51bGw+KFNUT1JBR0VfS0VZUy5DWUNMRV9TVEFSVCwgbnVsbCk7XG4gICAgaWYgKCFzdG9yZWQpIHtcbiAgICAgICAgc3RvcmVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLkNZQ0xFX1NUQVJULCBzdG9yZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3ljbGVTdGFydChkYXRlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5DWUNMRV9TVEFSVCwgZGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50RGF5SW5DeWNsZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoZ2V0Q3ljbGVTdGFydCgpKTtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgZGlmZiA9IE1hdGguZmxvb3IoKHRvZGF5LmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICByZXR1cm4gZGlmZiAlIHNldHRpbmdzLmNvbXBsZXRpb25EYXlzO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBCYWNrdXAgJiBSZXN0b3JlXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIE1hdHVyaXR5IExldmVsc1xuZXhwb3J0IHR5cGUgTWF0dXJpdHlMZXZlbCA9ICdyZXNldCcgfCAnbWVkaXVtJyB8ICdzdHJvbmcnIHwgJ21hc3RlcmVkJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFN1cmFoTWF0dXJpdHkoc3VyYWhJZDogbnVtYmVyLCBsZXZlbDogTWF0dXJpdHlMZXZlbCk6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gZ2V0TWVtb3J5Tm9kZXMoKTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgY29uc3QgdXBkYXRlZE5vZGVzID0gbm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5zdXJhaElkICE9PSBzdXJhaElkIHx8IChub2RlLnR5cGUgIT09ICd2ZXJzZScgJiYgbm9kZS50eXBlICE9PSAnbWluZG1hcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IDE7XG4gICAgICAgIGxldCBlZmFjdG9yID0gMi41O1xuXG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgIGludGVydmFsID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAgICAgIGludGVydmFsID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXN0ZXJlZCc6XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSA5MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBqaXR0ZXI6ICsvLSAyMCVcbiAgICAgICAgaWYgKGxldmVsICE9PSAncmVzZXQnKSB7XG4gICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBpbnRlcnZhbCAqIDAuMjtcbiAgICAgICAgICAgIGludGVydmFsID0gTWF0aC5yb3VuZChpbnRlcnZhbCArIChNYXRoLnJhbmRvbSgpICogaml0dGVyICogMiAtIGppdHRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHVlRGF0ZSA9IG5ldyBEYXRlKG5vdyk7XG4gICAgICAgIGR1ZURhdGUuc2V0RGF0ZShkdWVEYXRlLmdldERhdGUoKSArIGludGVydmFsKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHNjaGVkdWxlcjoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUuc2NoZWR1bGVyLFxuICAgICAgICAgICAgICAgIGludGVydmFsLFxuICAgICAgICAgICAgICAgIGVhc2VGYWN0b3I6IGVmYWN0b3IsIC8vIENvcnJlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gJ2VmYWN0b3InIHRvICdlYXNlRmFjdG9yJ1xuICAgICAgICAgICAgICAgIGR1ZURhdGU6IGR1ZURhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHNhdmVNZW1vcnlOb2Rlcyh1cGRhdGVkTm9kZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRBbGxNYXR1cml0eSgpOiB2b2lkIHtcbiAgICAvLyAxLiBDbGVhciBhbGwgbWVtb3J5IG5vZGVzXG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTUVNT1JZX05PREVTLCBbXSk7XG4gICAgXG4gICAgLy8gMi4gQ2xlYXIgYWxsIHJldmlldyBlcnJvcnNcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5SRVZJRVdfRVJST1JTLCBbXSk7XG5cbiAgICAvLyAzLiBSZWdlbmVyYXRlIG5vZGVzIGJhc2VkIG9uIGN1cnJlbnRseSBsZWFybmVkIHN1cmFocyBhbmQgY29tcGxldGVkIG1pbmRtYXBzXG4gICAgc3luY01lbW9yeU5vZGVzV2l0aExlYXJuZWQodHJ1ZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5jaG9ySXNzdWUge1xuICAgIGFuY2hvcklkOiBzdHJpbmc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBzdXJhaElkOiBudW1iZXI7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICBzdGFydFZlcnNlPzogbnVtYmVyO1xuICAgIGVuZFZlcnNlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQW5jaG9ycyh0aHJlc2hvbGQ6IG51bWJlciA9IDMpOiBBbmNob3JJc3N1ZVtdIHtcbiAgICByZXR1cm4gZ2V0RXJyb3JzQnlBbmNob3IoKVxuICAgICAgICAuZmlsdGVyKGUgPT4gZS5jb3VudCA+PSB0aHJlc2hvbGQgJiYgZS5zdXJhaElkICYmIGUuYW5jaG9ySWQpXG4gICAgICAgIC5tYXAoZSA9PiAoe1xuICAgICAgICAgICAgYW5jaG9ySWQ6IGUuYW5jaG9ySWQhLFxuICAgICAgICAgICAgbGFiZWw6IGUubGFiZWwsXG4gICAgICAgICAgICBzdXJhaElkOiBlLnN1cmFoSWQhLFxuICAgICAgICAgICAgY291bnQ6IGUuY291bnQsXG4gICAgICAgICAgICBzdGFydFZlcnNlOiBlLnN0YXJ0VmVyc2UsXG4gICAgICAgICAgICBlbmRWZXJzZTogZS5lbmRWZXJzZSxcbiAgICAgICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbmNob3JJc3N1ZXMoc3VyYWhJZDogbnVtYmVyLCBhbmNob3JJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZ2V0UmV2aWV3RXJyb3JzKCkuZmlsdGVyKGVyciA9PiAhKGVyci5zdXJhaElkID09PSBzdXJhaElkICYmIGVyci5hbmNob3JJZCA9PT0gYW5jaG9ySWQpKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuUkVWSUVXX0VSUk9SUywgSlNPTi5zdHJpbmdpZnkocmVtYWluaW5nKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQW5jaG9yRm9yUmFuZ2Uoc3VyYWhJZDogbnVtYmVyLCBzdGFydFZlcnNlPzogbnVtYmVyLCBlbmRWZXJzZT86IG51bWJlcik6IEFuY2hvciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgbWluZG1hcCA9IGdldE1pbmRNYXAoc3VyYWhJZCk7XG4gICAgaWYgKCFzdGFydFZlcnNlIHx8ICFlbmRWZXJzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWluZG1hcC5hbmNob3JzLmZpbmQoYSA9PiBhLnN0YXJ0VmVyc2UgPD0gc3RhcnRWZXJzZSAmJiBhLmVuZFZlcnNlID49IGVuZFZlcnNlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNdXRhc2hhYmloYXREZWNpc2lvbiB7XG4gICAgc3RhdHVzOiAncGVuZGluZycgfCAnaWdub3JlZCcgfCAnc29sdmVkX21pbmRtYXAnIHwgJ3NvbHZlZF9ub3RlJztcbiAgICBub3RlPzogc3RyaW5nO1xuICAgIGNvbmZpcm1lZEF0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbU11dGFzaGFiaWgge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdmVyc2UxOiB7IHN1cmFoSWQ6IG51bWJlcjsgYXlhaElkOiBudW1iZXIgfTtcbiAgICB2ZXJzZTI6IHsgc3VyYWhJZDogbnVtYmVyOyBheWFoSWQ6IG51bWJlciB9O1xuICAgIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2lnbm9yZWQnIHwgJ3NvbHZlZF9taW5kbWFwJyB8ICdzb2x2ZWRfbm90ZSc7XG4gICAgbm90ZT86IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgICBpc0N1c3RvbTogdHJ1ZTsgLy8gRGlzdGluY3Rpb24gZm9yIGRldmVsb3BtZW50IHB1cnBvc2VzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXN0b21NdXRhc2hhYmloYXQoKTogQ3VzdG9tTXV0YXNoYWJpaFtdIHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5DVVNUT01fTVVUQVNIQUJJSEFULCBbXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQ3VzdG9tTXV0YXNoYWJpaChtdXQ6IEN1c3RvbU11dGFzaGFiaWgpOiB2b2lkIHtcbiAgICBjb25zdCBhbGwgPSBnZXRDdXN0b21NdXRhc2hhYmloYXQoKTtcbiAgICBjb25zdCBleGlzdGluZ0lkeCA9IGFsbC5maW5kSW5kZXgobSA9PiBtLmlkID09PSBtdXQuaWQpO1xuICAgIGlmIChleGlzdGluZ0lkeCA+PSAwKSB7XG4gICAgICAgIGFsbFtleGlzdGluZ0lkeF0gPSBtdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxsLnB1c2gobXV0KTtcbiAgICB9XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuQ1VTVE9NX01VVEFTSEFCSUhBVCwgYWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUN1c3RvbU11dGFzaGFiaWgoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGFsbCA9IGdldEN1c3RvbU11dGFzaGFiaWhhdCgpLmZpbHRlcihtID0+IG0uaWQgIT09IGlkKTtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5DVVNUT01fTVVUQVNIQUJJSEFULCBhbGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TXV0YXNoYWJpaGF0RGVjaXNpb25zKCk6IFJlY29yZDxzdHJpbmcsIE11dGFzaGFiaWhhdERlY2lzaW9uPiB7XG4gICAgcmV0dXJuIGdldEZyb21DYWNoZShTVE9SQUdFX0tFWVMuTVVUQVNIQUJJSEFUX0RFQ0lTSU9OUywge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TXV0YXNoYWJpaGF0RGVjaXNpb24oYWJzb2x1dGVBeWFoOiBudW1iZXIsIGRlY2lzaW9uOiBNdXRhc2hhYmloYXREZWNpc2lvbiwgcGhyYXNlSWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkZWNpc2lvbnMgPSBnZXRNdXRhc2hhYmloYXREZWNpc2lvbnMoKTtcbiAgICBjb25zdCBrZXkgPSBwaHJhc2VJZCA/IGAke2Fic29sdXRlQXlhaH0tJHtwaHJhc2VJZH1gIDogYWJzb2x1dGVBeWFoLnRvU3RyaW5nKCk7XG4gICAgZGVjaXNpb25zW2tleV0gPSBkZWNpc2lvbjtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5NVVRBU0hBQklIQVRfREVDSVNJT05TLCBkZWNpc2lvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRNdXRhc2hhYmloYXREZWNpc2lvbnMoYWJzb2x1dGVBeWF0OiBudW1iZXJbXSk6IHZvaWQge1xuICAgIGNvbnN0IGRlY2lzaW9ucyA9IGdldE11dGFzaGFiaWhhdERlY2lzaW9ucygpO1xuICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IE9iamVjdC5rZXlzKGRlY2lzaW9ucykuZmlsdGVyKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGFicyA9IHBhcnNlSW50KGtleS5zcGxpdCgnLScpWzBdLCAxMCk7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZUF5YXQuaW5jbHVkZXMoYWJzKTtcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoa2V5c1RvRGVsZXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIFxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiBkZWxldGUgZGVjaXNpb25zW2tleV0pO1xuICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1VVEFTSEFCSUhBVF9ERUNJU0lPTlMsIGRlY2lzaW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWxrU2V0U3VyYWhTdGF0dXMoc3VyYWhJZHM6IG51bWJlcltdLCBzdGF0dXM6ICdsZWFybmVkJyB8ICduZXcnIHwgJ3NraXBwZWQnKTogdm9pZCB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IGFsbFN1cmFocyA9IFNVUkFIUztcblxuICAgIHN1cmFoSWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzdXJhaCA9IGFsbFN1cmFocy5maW5kKHMgPT4gcy5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoIXN1cmFoKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3VyYWhLZXkgPSBpZC50b1N0cmluZygpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgc3RhdGUgZm9yIHRoaXMgc3VyYWggZmlyc3RcbiAgICAgICAgZGVsZXRlIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldO1xuICAgICAgICBzZXR0aW5ncy5za2lwcGVkU3VyYWhzID0gKHNldHRpbmdzLnNraXBwZWRTdXJhaHMgfHwgW10pLmZpbHRlcihzSWQgPT4gc0lkICE9PSBpZCk7XG5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2xlYXJuZWQnKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzZUlkcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHN1cmFoLnZlcnNlQ291bnQgfSwgKF8sIGkpID0+IGkgKyAxKTtcbiAgICAgICAgICAgIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldID0gdmVyc2VJZHM7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnc2tpcHBlZCcpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNraXBwZWRTdXJhaHMgPSBbLi4uKHNldHRpbmdzLnNraXBwZWRTdXJhaHMgfHwgW10pLCBpZF07XG4gICAgICAgICAgICBwcnVuZVN1cmFoQXJ0aWZhY3RzKGlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAnbmV3JyBzdGF0dXMgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSByZXNldHMgYWJvdmVcbiAgICB9KTtcblxuICAgIGlmIChzZXR0aW5ncy5za2lwcGVkU3VyYWhzKSB7XG4gICAgICAgIHNldHRpbmdzLnNraXBwZWRTdXJhaHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cbiAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MpO1xufVxuXG5mdW5jdGlvbiBwcnVuZVN1cmFoQXJ0aWZhY3RzKHN1cmFoSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFJlbW92ZSBtZW1vcnkgbm9kZXMgZm9yIHRoaXMgc3VyYWhcbiAgICBjb25zdCBub2RlcyA9IGdldE1lbW9yeU5vZGVzKCkuZmlsdGVyKG4gPT4gbi5zdXJhaElkICE9PSBzdXJhaElkKTtcbiAgICBzYXZlTWVtb3J5Tm9kZXMobm9kZXMpO1xuXG4gICAgLy8gUmVtb3ZlIHN1cmFoIG1pbmRtYXBcbiAgICBjb25zdCBtYXBzID0gZ2V0TWluZE1hcHMoKTtcbiAgICBpZiAobWFwc1tzdXJhaElkXSkge1xuICAgICAgICBkZWxldGUgbWFwc1tzdXJhaElkXTtcbiAgICAgICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTUlORE1BUFMsIG1hcHMpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSByZXZpZXcgZXJyb3JzXG4gICAgY29uc3QgcmVtYWluaW5nRXJyb3JzID0gZ2V0UmV2aWV3RXJyb3JzKCkuZmlsdGVyKGVyciA9PiBlcnIuc3VyYWhJZCAhPT0gc3VyYWhJZCk7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuUkVWSUVXX0VSUk9SUywgcmVtYWluaW5nRXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlU3VzcGVuZGVkKG5vZGU6IE1lbW9yeU5vZGUsIGlzc3VlczogQW5jaG9ySXNzdWVbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghbm9kZS5zdXJhaElkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcmVsYXRlZElzc3VlcyA9IGlzc3Vlcy5maWx0ZXIoaSA9PiBpLnN1cmFoSWQgPT09IG5vZGUuc3VyYWhJZCk7XG4gICAgaWYgKHJlbGF0ZWRJc3N1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnbWluZG1hcCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd2ZXJzZScpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gZmluZEFuY2hvckZvclJhbmdlKG5vZGUuc3VyYWhJZCwgbm9kZS5zdGFydFZlcnNlLCBub2RlLmVuZFZlcnNlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IHJlbGF0ZWRJc3N1ZXMuc29tZShpID0+IGkuYW5jaG9ySWQgPT09IGFuY2hvci5pZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2t1cERhdGEge1xuICAgIHNldHRpbmdzPzogQXBwU2V0dGluZ3M7XG4gICAgbWVtb3J5Tm9kZXM/OiBNZW1vcnlOb2RlW107XG4gICAgbWluZG1hcHM/OiB7IFtzdXJhaElkOiBzdHJpbmddOiBNaW5kTWFwIH07XG4gICAgcGFydE1pbmRtYXBzPzogeyBbcGFydElkOiBzdHJpbmddOiBQYXJ0TWluZE1hcCB9O1xuICAgIGxpc3RlbmluZ1N0YXRzPzogeyBbc3VyYWhJZDogc3RyaW5nXTogTGlzdGVuaW5nU3RhdHMgfTtcbiAgICBsaXN0ZW5pbmdQcm9ncmVzcz86IFJlY29yZDxzdHJpbmcsIExpc3RlbmluZ1Byb2dyZXNzPjtcbiAgICByZXZpZXdFcnJvcnM/OiBSZXZpZXdFcnJvcltdO1xuICAgIG11dGFzaGFiaWhhdERlY2lzaW9ucz86IFJlY29yZDxzdHJpbmcsIE11dGFzaGFiaWhhdERlY2lzaW9uPjtcbiAgICBjdXN0b21NdXRhc2hhYmloYXQ/OiBDdXN0b21NdXRhc2hhYmloW107XG4gICAgY3ljbGVTdGFydD86IHN0cmluZztcbiAgICBsaXN0ZW5pbmdDb21wbGV0ZT86IHN0cmluZyB8IG51bGw7XG4gICAgZXhwb3J0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0QmFja3VwKCk6IEJhY2t1cERhdGEge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNldHRpbmdzOiBnZXRTZXR0aW5ncygpLFxuICAgICAgICBtZW1vcnlOb2RlczogZ2V0TWVtb3J5Tm9kZXMoKSxcbiAgICAgICAgbWluZG1hcHM6IGdldE1pbmRNYXBzKCksXG4gICAgICAgIHBhcnRNaW5kbWFwczogZ2V0UGFydE1pbmRNYXBzKCksXG4gICAgICAgIGxpc3RlbmluZ1N0YXRzOiBnZXRMaXN0ZW5pbmdTdGF0cygpLFxuICAgICAgICBsaXN0ZW5pbmdQcm9ncmVzczogZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfUFJPR1JFU1MsIHt9KSxcbiAgICAgICAgcmV2aWV3RXJyb3JzOiBnZXRSZXZpZXdFcnJvcnMoKSxcbiAgICAgICAgbXV0YXNoYWJpaGF0RGVjaXNpb25zOiBnZXRNdXRhc2hhYmloYXREZWNpc2lvbnMoKSxcbiAgICAgICAgY3VzdG9tTXV0YXNoYWJpaGF0OiBnZXRDdXN0b21NdXRhc2hhYmloYXQoKSxcbiAgICAgICAgY3ljbGVTdGFydDogZ2V0Q3ljbGVTdGFydCgpLFxuICAgICAgICBsaXN0ZW5pbmdDb21wbGV0ZTogZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfQ09NUExFVEUsIG51bGwpLFxuICAgICAgICBleHBvcnRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydEJhY2t1cChkYXRhOiBCYWNrdXBEYXRhKTogdm9pZCB7XG4gICAgaWYgKGRhdGEuc2V0dGluZ3MpIHNhdmVTZXR0aW5ncyhkYXRhLnNldHRpbmdzKTtcbiAgICBpZiAoZGF0YS5tZW1vcnlOb2Rlcykgc2F2ZU1lbW9yeU5vZGVzKGRhdGEubWVtb3J5Tm9kZXMpO1xuICAgIGlmIChkYXRhLm1pbmRtYXBzKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1JTkRNQVBTLCBkYXRhLm1pbmRtYXBzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucGFydE1pbmRtYXBzKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLlBBUlRfTUlORE1BUFMsIGRhdGEucGFydE1pbmRtYXBzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGlzdGVuaW5nU3RhdHMpIHtcbiAgICAgICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTElTVEVOSU5HX1NUQVRTLCBkYXRhLmxpc3RlbmluZ1N0YXRzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGlzdGVuaW5nUHJvZ3Jlc3MpIHtcbiAgICAgICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTElTVEVOSU5HX1BST0dSRVNTLCBkYXRhLmxpc3RlbmluZ1Byb2dyZXNzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucmV2aWV3RXJyb3JzKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLlJFVklFV19FUlJPUlMsIGRhdGEucmV2aWV3RXJyb3JzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubXV0YXNoYWJpaGF0RGVjaXNpb25zKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1VVEFTSEFCSUhBVF9ERUNJU0lPTlMsIGRhdGEubXV0YXNoYWJpaGF0RGVjaXNpb25zKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3VzdG9tTXV0YXNoYWJpaGF0KSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLkNVU1RPTV9NVVRBU0hBQklIQVQsIGRhdGEuY3VzdG9tTXV0YXNoYWJpaGF0KTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3ljbGVTdGFydCkgc2V0Q3ljbGVTdGFydChkYXRhLmN5Y2xlU3RhcnQpO1xuICAgIGlmIChkYXRhLmxpc3RlbmluZ0NvbXBsZXRlKSBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfQ09NUExFVEUsIGRhdGEubGlzdGVuaW5nQ29tcGxldGUpO1xufVxuIl0sIm5hbWVzIjpbIlNVUkFIUyIsImdldCIsInNldCIsImNyZWF0ZVN0b3JlIiwiY3VzdG9tU3RvcmUiLCJ1bmRlZmluZWQiLCJtaWdyYXRlRnJvbUxvY2FsU3RvcmFnZSIsIm1pZ3JhdGlvbkZsYWciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwia2V5IiwiT2JqZWN0IiwidmFsdWVzIiwiU1RPUkFHRV9LRVlTIiwidmFsdWUiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwic2V0SXRlbSIsImxvZyIsInN0b3JhZ2VDYWNoZSIsImxvYWRJbnRvQ2FjaGUiLCJnZXRGcm9tQ2FjaGUiLCJkZWZhdWx0VmFsdWUiLCJjYWNoZWQiLCJzYXZlVG9DYWNoZUFuZFN0b3JlIiwiY2F0Y2giLCJlcnIiLCJTRVRUSU5HUyIsIk1FTU9SWV9OT0RFUyIsIk1JTkRNQVBTIiwiUEFSVF9NSU5ETUFQUyIsIkxJU1RFTklOR19QUk9HUkVTUyIsIkxJU1RFTklOR19TVEFUUyIsIkNZQ0xFX1NUQVJUIiwiTElTVEVOSU5HX0NPTVBMRVRFIiwiUkVWSUVXX0VSUk9SUyIsIk1VVEFTSEFCSUhBVF9ERUNJU0lPTlMiLCJDVVNUT01fTVVUQVNIQUJJSEFUIiwiREVGQVVMVF9TRVRUSU5HUyIsImNvbXBsZXRpb25EYXlzIiwiYWN0aXZlUGFydCIsImxlYXJuZWRWZXJzZXMiLCJza2lwcGVkU3VyYWhzIiwiZ2V0U2V0dGluZ3MiLCJzYXZlU2V0dGluZ3MiLCJzZXR0aW5ncyIsInVwZGF0ZVNldHRpbmciLCJpc1N1cmFoU2tpcHBlZCIsInN1cmFoSWQiLCJpbmNsdWRlcyIsInRvZ2dsZVN1cmFoU2tpcHBlZCIsImN1cnJlbnQiLCJTZXQiLCJoYXMiLCJkZWxldGUiLCJhZGQiLCJwcnVuZVN1cmFoQXJ0aWZhY3RzIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwiaXNWZXJzZUxlYXJuZWQiLCJheWFoSWQiLCJ0b2dnbGVWZXJzZUxlYXJuZWQiLCJzdXJhaEtleSIsInRvU3RyaW5nIiwiZmlsdGVyIiwidiIsImxlbmd0aCIsInN5bmNNZW1vcnlOb2Rlc1dpdGhMZWFybmVkIiwidG9nZ2xlU3VyYWhMZWFybmVkIiwic3VyYWgiLCJmaW5kIiwicyIsImlkIiwidmVyc2VDb3VudCIsIl8iLCJpIiwiZ2V0U3VyYWhMZWFybmVkU3RhdHVzIiwibGVhcm5lZCIsInRvdGFsIiwiZ2V0VG90YWxMZWFybmVkVmVyc2VzIiwicmVkdWNlIiwic3VtIiwidmVyc2VzIiwiZ2V0TGVhcm5lZFZlcnNlc0luUGFydCIsInBhcnQiLCJyZXN1bHQiLCJmb3JFYWNoIiwicHVzaCIsImdldE1lbW9yeU5vZGVzIiwic2F2ZU1lbW9yeU5vZGVzIiwibm9kZXMiLCJnZXREdWVOb2RlcyIsInRvZGF5IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJza2lwcyIsInN1c3BlbmRlZCIsImdldFN1c3BlbmRlZEFuY2hvcnMiLCJuIiwic2NoZWR1bGVyIiwiZHVlRGF0ZSIsImlzTm9kZVN1c3BlbmRlZCIsInVwZGF0ZU1lbW9yeU5vZGUiLCJub2RlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjcmVhdGVOZXdTY2hlZHVsZXIiLCJpbnRlcnZhbCIsInJlcGV0aXRpb24iLCJlYXNlRmFjdG9yIiwibGFzdFJldmlldyIsImZvcmNlRnVsbFJlc2V0IiwiZW50cmllcyIsInN1cmFoSWRTdHIiLCJwYXJzZUludCIsInNvcnRlZFZlcnNlcyIsInNlZ21lbnRTdGFydCIsInNlZ21lbnRFbmQiLCJpc0NvbnRpZ3VvdXMiLCJzZWdtZW50U2l6ZSIsIm5vZGVJZCIsImV4aXN0cyIsInNvbWUiLCJuZXdOb2RlIiwidHlwZSIsInN0YXJ0VmVyc2UiLCJlbmRWZXJzZSIsIm1pbmRtYXBzIiwiZ2V0TWluZE1hcHMiLCJtbSIsImlzQ29tcGxldGUiLCJwYXJ0TWluZG1hcHMiLCJnZXRQYXJ0TWluZE1hcHMiLCJwbW0iLCJwYXJ0SWQiLCJzbTIiLCJncmFkZSIsInN0YXRlIiwiTWF0aCIsInJvdW5kIiwibWF4Iiwic2V0RGF0ZSIsImdldERhdGUiLCJwb3N0cG9uZU5vZGUiLCJ0b21vcnJvdyIsImdldE1pbmRNYXAiLCJtYXBzIiwiaW1hZ2VVcmwiLCJhbmNob3JzIiwic2F2ZU1pbmRNYXAiLCJtaW5kbWFwIiwiZ2V0UGFydE1pbmRNYXAiLCJkZXNjcmlwdGlvbiIsInNhdmVQYXJ0TWluZE1hcCIsImdldExpc3RlbmluZ1Byb2dyZXNzIiwibWFwIiwiY3VycmVudFZlcnNlSW5kZXgiLCJzYXZlTGlzdGVuaW5nUHJvZ3Jlc3MiLCJnZXRMaXN0ZW5pbmdTdGF0cyIsImdldExpc3RlbmluZ1N0YXRzRm9yU3VyYWgiLCJzdGF0cyIsInRvdGFsTWludXRlcyIsImxhc3RMaXN0ZW5lZCIsImFkZExpc3RlbmluZ1RpbWUiLCJtaW51dGVzIiwiZ2V0TGlzdGVuaW5nQ29tcGxldGVkVG9kYXkiLCJzdG9yZWQiLCJtYXJrTGlzdGVuaW5nQ29tcGxldGUiLCJnZXRSZXZpZXdFcnJvcnMiLCJzYXZlUmV2aWV3RXJyb3IiLCJlcnJvcnMiLCJ0cmltbWVkIiwic2xpY2UiLCJyZW1vdmVSZXZpZXdFcnJvciIsInJlbWFpbmluZyIsImdldEVycm9yc0J5QW5jaG9yIiwiYW5jaG9yQ291bnRzIiwiYW5jaG9yIiwibGFiZWwiLCJjb3VudCIsImFuY2hvcklkIiwiZ2V0Q3ljbGVTdGFydCIsInNldEN5Y2xlU3RhcnQiLCJkYXRlIiwiZ2V0Q3VycmVudERheUluQ3ljbGUiLCJzdGFydCIsImRpZmYiLCJmbG9vciIsImdldFRpbWUiLCJzZXRTdXJhaE1hdHVyaXR5IiwibGV2ZWwiLCJub3ciLCJ1cGRhdGVkTm9kZXMiLCJlZmFjdG9yIiwiaml0dGVyIiwicmFuZG9tIiwicmVzZXRBbGxNYXR1cml0eSIsInRocmVzaG9sZCIsImNsZWFyQW5jaG9ySXNzdWVzIiwic3RyaW5naWZ5IiwiZmluZEFuY2hvckZvclJhbmdlIiwiZ2V0Q3VzdG9tTXV0YXNoYWJpaGF0Iiwic2F2ZUN1c3RvbU11dGFzaGFiaWgiLCJtdXQiLCJhbGwiLCJleGlzdGluZ0lkeCIsIm0iLCJkZWxldGVDdXN0b21NdXRhc2hhYmloIiwiZ2V0TXV0YXNoYWJpaGF0RGVjaXNpb25zIiwic2V0TXV0YXNoYWJpaGF0RGVjaXNpb24iLCJhYnNvbHV0ZUF5YWgiLCJkZWNpc2lvbiIsInBocmFzZUlkIiwiZGVjaXNpb25zIiwicmVzZXRNdXRhc2hhYmloYXREZWNpc2lvbnMiLCJhYnNvbHV0ZUF5YXQiLCJrZXlzVG9EZWxldGUiLCJrZXlzIiwiYWJzIiwiYnVsa1NldFN1cmFoU3RhdHVzIiwic3VyYWhJZHMiLCJzdGF0dXMiLCJhbGxTdXJhaHMiLCJzSWQiLCJ2ZXJzZUlkcyIsInJlbWFpbmluZ0Vycm9ycyIsImlzc3VlcyIsInJlbGF0ZWRJc3N1ZXMiLCJleHBvcnRCYWNrdXAiLCJtZW1vcnlOb2RlcyIsImxpc3RlbmluZ1N0YXRzIiwibGlzdGVuaW5nUHJvZ3Jlc3MiLCJyZXZpZXdFcnJvcnMiLCJtdXRhc2hhYmloYXREZWNpc2lvbnMiLCJjdXN0b21NdXRhc2hhYmloYXQiLCJjeWNsZVN0YXJ0IiwibGlzdGVuaW5nQ29tcGxldGUiLCJleHBvcnRlZEF0IiwiaW1wb3J0QmFja3VwIiwiZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/storage.ts\n"));

/***/ })

});