"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/storage.ts":
/*!****************************!*\
  !*** ./src/lib/storage.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListeningTime: function() { return /* binding */ addListeningTime; },\n/* harmony export */   bulkSetSurahStatus: function() { return /* binding */ bulkSetSurahStatus; },\n/* harmony export */   clearAnchorIssues: function() { return /* binding */ clearAnchorIssues; },\n/* harmony export */   deleteCustomMutashabih: function() { return /* binding */ deleteCustomMutashabih; },\n/* harmony export */   exportBackup: function() { return /* binding */ exportBackup; },\n/* harmony export */   findAnchorForRange: function() { return /* binding */ findAnchorForRange; },\n/* harmony export */   getCurrentDayInCycle: function() { return /* binding */ getCurrentDayInCycle; },\n/* harmony export */   getCustomMutashabihat: function() { return /* binding */ getCustomMutashabihat; },\n/* harmony export */   getCycleStart: function() { return /* binding */ getCycleStart; },\n/* harmony export */   getDueNodes: function() { return /* binding */ getDueNodes; },\n/* harmony export */   getErrorsByAnchor: function() { return /* binding */ getErrorsByAnchor; },\n/* harmony export */   getLearnedVersesInPart: function() { return /* binding */ getLearnedVersesInPart; },\n/* harmony export */   getListeningCompletedToday: function() { return /* binding */ getListeningCompletedToday; },\n/* harmony export */   getListeningProgress: function() { return /* binding */ getListeningProgress; },\n/* harmony export */   getListeningStats: function() { return /* binding */ getListeningStats; },\n/* harmony export */   getListeningStatsForSurah: function() { return /* binding */ getListeningStatsForSurah; },\n/* harmony export */   getMemoryNodes: function() { return /* binding */ getMemoryNodes; },\n/* harmony export */   getMindMap: function() { return /* binding */ getMindMap; },\n/* harmony export */   getMindMaps: function() { return /* binding */ getMindMaps; },\n/* harmony export */   getMutashabihatDecisions: function() { return /* binding */ getMutashabihatDecisions; },\n/* harmony export */   getPartMindMap: function() { return /* binding */ getPartMindMap; },\n/* harmony export */   getPartMindMaps: function() { return /* binding */ getPartMindMaps; },\n/* harmony export */   getReviewErrors: function() { return /* binding */ getReviewErrors; },\n/* harmony export */   getSettings: function() { return /* binding */ getSettings; },\n/* harmony export */   getSurahLearnedStatus: function() { return /* binding */ getSurahLearnedStatus; },\n/* harmony export */   getSuspendedAnchors: function() { return /* binding */ getSuspendedAnchors; },\n/* harmony export */   getTotalLearnedVerses: function() { return /* binding */ getTotalLearnedVerses; },\n/* harmony export */   importBackup: function() { return /* binding */ importBackup; },\n/* harmony export */   isSurahSkipped: function() { return /* binding */ isSurahSkipped; },\n/* harmony export */   isVerseLearned: function() { return /* binding */ isVerseLearned; },\n/* harmony export */   markListeningComplete: function() { return /* binding */ markListeningComplete; },\n/* harmony export */   postponeNode: function() { return /* binding */ postponeNode; },\n/* harmony export */   removeReviewError: function() { return /* binding */ removeReviewError; },\n/* harmony export */   resetAllMaturity: function() { return /* binding */ resetAllMaturity; },\n/* harmony export */   resetMutashabihatDecisions: function() { return /* binding */ resetMutashabihatDecisions; },\n/* harmony export */   saveCustomMutashabih: function() { return /* binding */ saveCustomMutashabih; },\n/* harmony export */   saveListeningProgress: function() { return /* binding */ saveListeningProgress; },\n/* harmony export */   saveMemoryNodes: function() { return /* binding */ saveMemoryNodes; },\n/* harmony export */   saveMindMap: function() { return /* binding */ saveMindMap; },\n/* harmony export */   savePartMindMap: function() { return /* binding */ savePartMindMap; },\n/* harmony export */   saveReviewError: function() { return /* binding */ saveReviewError; },\n/* harmony export */   saveSettings: function() { return /* binding */ saveSettings; },\n/* harmony export */   setCycleStart: function() { return /* binding */ setCycleStart; },\n/* harmony export */   setMutashabihatDecision: function() { return /* binding */ setMutashabihatDecision; },\n/* harmony export */   setSurahMaturity: function() { return /* binding */ setSurahMaturity; },\n/* harmony export */   sm2: function() { return /* binding */ sm2; },\n/* harmony export */   syncMemoryNodesWithLearned: function() { return /* binding */ syncMemoryNodesWithLearned; },\n/* harmony export */   toggleSurahLearned: function() { return /* binding */ toggleSurahLearned; },\n/* harmony export */   toggleSurahSkipped: function() { return /* binding */ toggleSurahSkipped; },\n/* harmony export */   toggleVerseLearned: function() { return /* binding */ toggleVerseLearned; },\n/* harmony export */   updateMemoryNode: function() { return /* binding */ updateMemoryNode; },\n/* harmony export */   updateSetting: function() { return /* binding */ updateSetting; }\n/* harmony export */ });\n/* harmony import */ var _quranData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quranData */ \"(app-pages-browser)/./src/lib/quranData.ts\");\n/* harmony import */ var idb_keyval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb-keyval */ \"(app-pages-browser)/./node_modules/idb-keyval/dist/index.js\");\n// ========================================\n// Storage Service - With Part Mindmaps & Review Errors\n// ========================================\n\n\n// ========================================\n// Storage Engine Migration & Helpers\n// ========================================\nconst customStore =  true ? (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.createStore)(\"quran-app-db\", \"quran-app-store\") : 0;\n/**\n * Migration helper to move data from localStorage to IndexedDB once.\n */ async function migrateFromLocalStorage() {\n    if ( false || !customStore) return;\n    const migrationFlag = \"quran-app-migrated-to-idb\";\n    if (localStorage.getItem(migrationFlag)) return;\n    for (const key of Object.values(STORAGE_KEYS)){\n        const value = localStorage.getItem(key);\n        if (value) {\n            try {\n                await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.set)(key, JSON.parse(value), customStore);\n            } catch (e) {\n                console.error(\"Migration failed for key \".concat(key, \":\"), e);\n            }\n        }\n    }\n    localStorage.setItem(migrationFlag, \"true\");\n    console.log(\"Successfully migrated data from localStorage to IndexedDB\");\n}\n// Initial migration trigger\nif (true) {\n    migrateFromLocalStorage();\n}\n/**\n * Global cache to keep synchronous access for existing UI while persisting asynchronously.\n * This ensures the UI remains snappy while data is safely stored in IndexedDB.\n */ const storageCache = {};\nasync function loadIntoCache() {\n    if ( false || !customStore) return;\n    for (const key of Object.values(STORAGE_KEYS)){\n        storageCache[key] = await (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.get)(key, customStore);\n    }\n}\n// Start loading cache\nif (true) {\n    loadIntoCache();\n}\nfunction getFromCache(key, defaultValue) {\n    if (false) {}\n    const cached = storageCache[key];\n    return cached !== undefined ? cached : defaultValue;\n}\nfunction saveToCacheAndStore(key, value) {\n    storageCache[key] = value;\n    if ( true && customStore) {\n        (0,idb_keyval__WEBPACK_IMPORTED_MODULE_1__.set)(key, value, customStore).catch((err)=>console.error(\"Failed to persist \".concat(key, \":\"), err));\n    }\n}\nconst STORAGE_KEYS = {\n    SETTINGS: \"quran-app-settings\",\n    MEMORY_NODES: \"quran-app-memory-nodes\",\n    MINDMAPS: \"quran-app-mindmaps\",\n    PART_MINDMAPS: \"quran-app-part-mindmaps\",\n    LISTENING_PROGRESS: \"quran-app-listening-progress\",\n    LISTENING_STATS: \"quran-app-listening-stats\",\n    CYCLE_START: \"quran-app-cycle-start\",\n    LISTENING_COMPLETE: \"quran-app-listening-complete\",\n    REVIEW_ERRORS: \"quran-app-review-errors\",\n    MUTASHABIHAT_DECISIONS: \"quran-app-mutashabihat-decisions\",\n    CUSTOM_MUTASHABIHAT: \"quran-app-custom-mutashabihat\"\n};\nconst DEFAULT_SETTINGS = {\n    completionDays: 30,\n    activePart: 4,\n    learnedVerses: {},\n    skippedSurahs: []\n};\nfunction getSettings() {\n    return getFromCache(STORAGE_KEYS.SETTINGS, DEFAULT_SETTINGS);\n}\nfunction saveSettings(settings) {\n    saveToCacheAndStore(STORAGE_KEYS.SETTINGS, settings);\n}\nfunction updateSetting(key, value) {\n    const settings = getSettings();\n    settings[key] = value;\n    saveSettings(settings);\n}\nfunction isSurahSkipped(surahId) {\n    var _settings_skippedSurahs;\n    const settings = getSettings();\n    return ((_settings_skippedSurahs = settings.skippedSurahs) === null || _settings_skippedSurahs === void 0 ? void 0 : _settings_skippedSurahs.includes(surahId)) || false;\n}\nfunction toggleSurahSkipped(surahId) {\n    const settings = getSettings();\n    const current = new Set(settings.skippedSurahs || []);\n    if (current.has(surahId)) {\n        current.delete(surahId);\n    } else {\n        current.add(surahId);\n        // Also remove any learned data for this surah\n        if (settings.learnedVerses[surahId]) {\n            delete settings.learnedVerses[surahId];\n        }\n        pruneSurahArtifacts(surahId);\n    }\n    settings.skippedSurahs = Array.from(current).sort((a, b)=>a - b);\n    saveSettings(settings);\n}\n// ========================================\n// Learned Verses Helpers\n// ========================================\nfunction isVerseLearned(surahId, ayahId) {\n    var _settings_learnedVerses_surahId;\n    const settings = getSettings();\n    return ((_settings_learnedVerses_surahId = settings.learnedVerses[surahId]) === null || _settings_learnedVerses_surahId === void 0 ? void 0 : _settings_learnedVerses_surahId.includes(ayahId)) || false;\n}\nfunction toggleVerseLearned(surahId, ayahId) {\n    const settings = getSettings();\n    const surahKey = surahId.toString();\n    const current = settings.learnedVerses[surahKey] || [];\n    if (current.includes(ayahId)) {\n        settings.learnedVerses[surahKey] = current.filter((v)=>v !== ayahId);\n        if (settings.learnedVerses[surahKey].length === 0) {\n            delete settings.learnedVerses[surahKey];\n        }\n    } else {\n        settings.learnedVerses[surahKey] = [\n            ...current,\n            ayahId\n        ].sort((a, b)=>a - b);\n    }\n    saveSettings(settings);\n    syncMemoryNodesWithLearned();\n}\nfunction toggleSurahLearned(surahId) {\n    const settings = getSettings();\n    const surah = _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS.find((s)=>s.id === surahId);\n    if (!surah) return;\n    const surahKey = surahId.toString();\n    const current = settings.learnedVerses[surahKey] || [];\n    if (current.length === surah.verseCount) {\n        delete settings.learnedVerses[surahKey];\n    } else {\n        settings.learnedVerses[surahKey] = Array.from({\n            length: surah.verseCount\n        }, (_, i)=>i + 1);\n    }\n    saveSettings(settings);\n    syncMemoryNodesWithLearned();\n}\nfunction getSurahLearnedStatus(surahId) {\n    var _settings_learnedVerses_surahId;\n    const settings = getSettings();\n    const surah = _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS.find((s)=>s.id === surahId);\n    if (!surah) return {\n        learned: 0,\n        total: 0\n    };\n    const learned = ((_settings_learnedVerses_surahId = settings.learnedVerses[surahId]) === null || _settings_learnedVerses_surahId === void 0 ? void 0 : _settings_learnedVerses_surahId.length) || 0;\n    return {\n        learned,\n        total: surah.verseCount\n    };\n}\nfunction getTotalLearnedVerses() {\n    const settings = getSettings();\n    return Object.values(settings.learnedVerses).reduce((sum, verses)=>sum + verses.length, 0);\n}\nfunction getLearnedVersesInPart(part) {\n    const settings = getSettings();\n    const result = [];\n    _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS.filter((s)=>s.part === part).forEach((surah)=>{\n        const verses = settings.learnedVerses[surah.id] || [];\n        verses.forEach((ayahId)=>{\n            result.push({\n                surahId: surah.id,\n                ayahId\n            });\n        });\n    });\n    return result;\n}\nfunction getMemoryNodes() {\n    return getFromCache(STORAGE_KEYS.MEMORY_NODES, []);\n}\nfunction saveMemoryNodes(nodes) {\n    saveToCacheAndStore(STORAGE_KEYS.MEMORY_NODES, nodes);\n}\nfunction getDueNodes() {\n    const today = new Date().toISOString().split(\"T\")[0];\n    const settings = getSettings();\n    const skips = new Set(settings.skippedSurahs || []);\n    const suspended = getSuspendedAnchors();\n    return getMemoryNodes().filter((n)=>n.scheduler.dueDate <= today).filter((n)=>!n.surahId || !skips.has(n.surahId)).filter((n)=>!isNodeSuspended(n, suspended));\n}\nfunction updateMemoryNode(node) {\n    const nodes = getMemoryNodes();\n    const index = nodes.findIndex((n)=>n.id === node.id);\n    if (index >= 0) {\n        nodes[index] = node;\n    } else {\n        nodes.push(node);\n    }\n    saveMemoryNodes(nodes);\n}\nfunction createNewScheduler() {\n    const today = new Date().toISOString().split(\"T\")[0];\n    return {\n        interval: 0,\n        repetition: 0,\n        easeFactor: 2.5,\n        dueDate: today,\n        lastReview: \"\"\n    };\n}\n// Sync memory nodes with learned verses - create nodes for learned verses\nfunction syncMemoryNodesWithLearned() {\n    let forceFullReset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    const settings = getSettings();\n    const nodes = forceFullReset ? [] : getMemoryNodes();\n    // Group verses into segments of 5\n    Object.entries(settings.learnedVerses).forEach((param)=>{\n        let [surahIdStr, verses] = param;\n        const surahId = parseInt(surahIdStr);\n        if (verses.length === 0) return;\n        // Create segments of 5 verses\n        const sortedVerses = [\n            ...verses\n        ].sort((a, b)=>a - b);\n        let segmentStart = sortedVerses[0];\n        let segmentEnd = segmentStart;\n        for(let i = 1; i <= sortedVerses.length; i++){\n            const isContiguous = i < sortedVerses.length && sortedVerses[i] === segmentEnd + 1;\n            const segmentSize = segmentEnd - segmentStart + 1;\n            if (!isContiguous || segmentSize >= 5 || i === sortedVerses.length) {\n                // Create node for this segment if it doesn't exist\n                const nodeId = \"verse-\".concat(surahId, \"-\").concat(segmentStart, \"-\").concat(segmentEnd);\n                const exists = nodes.some((n)=>n.id === nodeId);\n                if (!exists || forceFullReset) {\n                    const newNode = {\n                        id: nodeId,\n                        type: \"verse\",\n                        surahId,\n                        startVerse: segmentStart,\n                        endVerse: segmentEnd,\n                        scheduler: createNewScheduler()\n                    };\n                    if (forceFullReset) {\n                        nodes.push(newNode);\n                    } else if (!exists) {\n                        nodes.push(newNode);\n                    }\n                }\n                if (i < sortedVerses.length) {\n                    segmentStart = sortedVerses[i];\n                    segmentEnd = segmentStart;\n                }\n            } else {\n                segmentEnd = sortedVerses[i];\n            }\n        }\n    });\n    if (forceFullReset) {\n        // Also sync mindmaps\n        const mindmaps = getMindMaps();\n        Object.values(mindmaps).forEach((mm)=>{\n            if (mm.isComplete) {\n                nodes.push({\n                    id: \"mindmap-\".concat(mm.surahId),\n                    type: \"mindmap\",\n                    surahId: mm.surahId,\n                    scheduler: createNewScheduler()\n                });\n            }\n        });\n        // Also sync part mindmaps\n        const partMindmaps = getPartMindMaps();\n        Object.values(partMindmaps).forEach((pmm)=>{\n            if (pmm.isComplete) {\n                nodes.push({\n                    id: \"part-mindmap-\".concat(pmm.partId),\n                    type: \"part_mindmap\",\n                    partId: pmm.partId,\n                    scheduler: createNewScheduler()\n                });\n            }\n        });\n    }\n    saveMemoryNodes(nodes);\n}\n// SM-2 Algorithm\nfunction sm2(grade, state) {\n    let { interval, repetition, easeFactor } = state;\n    if (grade < 3) {\n        repetition = 0;\n        interval = 1;\n    } else {\n        if (repetition === 0) interval = 1;\n        else if (repetition === 1) interval = 6;\n        else interval = Math.round(interval * easeFactor);\n        repetition++;\n    }\n    easeFactor = Math.max(1.3, easeFactor + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)));\n    const dueDate = new Date();\n    dueDate.setDate(dueDate.getDate() + interval);\n    return {\n        interval,\n        repetition,\n        easeFactor: Math.round(easeFactor * 100) / 100,\n        dueDate: dueDate.toISOString().split(\"T\")[0],\n        lastReview: new Date().toISOString().split(\"T\")[0]\n    };\n}\nfunction postponeNode(node) {\n    const tomorrow = new Date();\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    return {\n        ...node,\n        scheduler: {\n            ...node.scheduler,\n            dueDate: tomorrow.toISOString().split(\"T\")[0],\n            lastReview: new Date().toISOString().split(\"T\")[0]\n        }\n    };\n}\nfunction getMindMaps() {\n    return getFromCache(STORAGE_KEYS.MINDMAPS, {});\n}\nfunction getMindMap(surahId) {\n    const maps = getMindMaps();\n    return maps[surahId] || {\n        surahId,\n        imageUrl: null,\n        anchors: [],\n        isComplete: false\n    };\n}\nfunction saveMindMap(mindmap) {\n    const maps = getMindMaps();\n    maps[mindmap.surahId] = mindmap;\n    saveToCacheAndStore(STORAGE_KEYS.MINDMAPS, maps);\n    // Create/update memory node for mindmap if complete\n    if (mindmap.isComplete) {\n        const nodes = getMemoryNodes();\n        const nodeId = \"mindmap-\".concat(mindmap.surahId);\n        const exists = nodes.some((n)=>n.id === nodeId);\n        if (!exists) {\n            nodes.push({\n                id: nodeId,\n                type: \"mindmap\",\n                surahId: mindmap.surahId,\n                scheduler: createNewScheduler()\n            });\n            saveMemoryNodes(nodes);\n        }\n    }\n}\nfunction getPartMindMaps() {\n    return getFromCache(STORAGE_KEYS.PART_MINDMAPS, {});\n}\nfunction getPartMindMap(partId) {\n    const maps = getPartMindMaps();\n    return maps[partId] || {\n        partId,\n        imageUrl: null,\n        description: \"\",\n        isComplete: false\n    };\n}\nfunction savePartMindMap(mindmap) {\n    const maps = getPartMindMaps();\n    maps[mindmap.partId] = mindmap;\n    saveToCacheAndStore(STORAGE_KEYS.PART_MINDMAPS, maps);\n    // Create memory node for part mindmap if complete\n    if (mindmap.isComplete) {\n        const nodes = getMemoryNodes();\n        const nodeId = \"part-mindmap-\".concat(mindmap.partId);\n        const exists = nodes.some((n)=>n.id === nodeId);\n        if (!exists) {\n            nodes.push({\n                id: nodeId,\n                type: \"part_mindmap\",\n                partId: mindmap.partId,\n                scheduler: createNewScheduler()\n            });\n            saveMemoryNodes(nodes);\n        }\n    }\n}\nfunction getListeningProgress(partId) {\n    const map = getFromCache(STORAGE_KEYS.LISTENING_PROGRESS, {});\n    return map[partId] || {\n        partId,\n        currentVerseIndex: 0\n    };\n}\nfunction saveListeningProgress(partId, currentVerseIndex) {\n    const map = getFromCache(STORAGE_KEYS.LISTENING_PROGRESS, {});\n    map[partId] = {\n        partId,\n        currentVerseIndex\n    };\n    saveToCacheAndStore(STORAGE_KEYS.LISTENING_PROGRESS, map);\n}\nfunction getListeningStats() {\n    return getFromCache(STORAGE_KEYS.LISTENING_STATS, {});\n}\nfunction getListeningStatsForSurah(surahId) {\n    const stats = getListeningStats();\n    return stats[surahId] || {\n        surahId,\n        totalMinutes: 0,\n        lastListened: \"\"\n    };\n}\nfunction addListeningTime(surahId, minutes) {\n    const stats = getListeningStats();\n    const current = stats[surahId] || {\n        surahId,\n        totalMinutes: 0,\n        lastListened: \"\"\n    };\n    current.totalMinutes += minutes;\n    current.lastListened = new Date().toISOString();\n    stats[surahId] = current;\n    saveToCacheAndStore(STORAGE_KEYS.LISTENING_STATS, stats);\n}\n// ========================================\n// Listening Complete Tracking\n// ========================================\nfunction getListeningCompletedToday() {\n    const stored = getFromCache(STORAGE_KEYS.LISTENING_COMPLETE, null);\n    if (!stored) return false;\n    const today = new Date().toISOString().split(\"T\")[0];\n    return stored === today;\n}\nfunction markListeningComplete() {\n    const today = new Date().toISOString().split(\"T\")[0];\n    saveToCacheAndStore(STORAGE_KEYS.LISTENING_COMPLETE, today);\n}\nfunction getReviewErrors() {\n    return getFromCache(STORAGE_KEYS.REVIEW_ERRORS, []);\n}\nfunction saveReviewError(error) {\n    const errors = getReviewErrors();\n    errors.push(error);\n    // Keep only last 100 errors\n    const trimmed = errors.slice(-100);\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, trimmed);\n}\nfunction removeReviewError(id) {\n    const errors = getReviewErrors();\n    const remaining = errors.filter((e)=>e.id !== id);\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, remaining);\n}\nfunction getErrorsByAnchor() {\n    const errors = getReviewErrors();\n    const mindmaps = getMindMaps();\n    const anchorCounts = {};\n    errors.filter((e)=>e.grade < 3).forEach((error)=>{\n        if (error.surahId && error.startVerse && error.endVerse) {\n            const mindmap = mindmaps[error.surahId];\n            if (mindmap) {\n                const anchor = mindmap.anchors.find((a)=>a.startVerse <= error.startVerse && a.endVerse >= error.endVerse);\n                if (anchor) {\n                    const key = \"\".concat(error.surahId, \"-\").concat(anchor.id);\n                    if (!anchorCounts[key]) {\n                        anchorCounts[key] = {\n                            label: anchor.label,\n                            count: 0,\n                            surahId: error.surahId,\n                            anchorId: anchor.id,\n                            startVerse: anchor.startVerse,\n                            endVerse: anchor.endVerse\n                        };\n                    }\n                    anchorCounts[key].count++;\n                }\n            }\n        }\n    });\n    return Object.values(anchorCounts).sort((a, b)=>b.count - a.count);\n}\n// ========================================\n// Cycle Management\n// ========================================\nfunction getCycleStart() {\n    let stored = getFromCache(STORAGE_KEYS.CYCLE_START, null);\n    if (!stored) {\n        stored = new Date().toISOString().split(\"T\")[0];\n        saveToCacheAndStore(STORAGE_KEYS.CYCLE_START, stored);\n    }\n    return stored;\n}\nfunction setCycleStart(date) {\n    saveToCacheAndStore(STORAGE_KEYS.CYCLE_START, date);\n}\nfunction getCurrentDayInCycle() {\n    const start = new Date(getCycleStart());\n    const today = new Date();\n    const diff = Math.floor((today.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n    const settings = getSettings();\n    return diff % settings.completionDays;\n}\nfunction setSurahMaturity(surahId, level) {\n    const nodes = getMemoryNodes();\n    const now = new Date();\n    const updatedNodes = nodes.map((node)=>{\n        if (node.surahId !== surahId || node.type !== \"verse\" && node.type !== \"mindmap\") {\n            return node;\n        }\n        let interval = 1;\n        let efactor = 2.5;\n        switch(level){\n            case \"reset\":\n                interval = 1;\n                break;\n            case \"medium\":\n                interval = 14;\n                break;\n            case \"strong\":\n                interval = 30;\n                break;\n            case \"mastered\":\n                interval = 90;\n                break;\n        }\n        // Add jitter: +/- 20%\n        if (level !== \"reset\") {\n            const jitter = interval * 0.2;\n            interval = Math.round(interval + (Math.random() * jitter * 2 - jitter));\n        }\n        const dueDate = new Date(now);\n        dueDate.setDate(dueDate.getDate() + interval);\n        return {\n            ...node,\n            scheduler: {\n                ...node.scheduler,\n                interval,\n                easeFactor: efactor,\n                dueDate: dueDate.toISOString()\n            }\n        };\n    });\n    saveMemoryNodes(updatedNodes);\n}\nfunction resetAllMaturity() {\n    // 1. Clear all memory nodes\n    saveToCacheAndStore(STORAGE_KEYS.MEMORY_NODES, []);\n    // 2. Clear all review errors\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, []);\n    // 3. Regenerate nodes based on currently learned surahs and completed mindmaps\n    syncMemoryNodesWithLearned(true);\n}\nfunction getSuspendedAnchors() {\n    let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n    return getErrorsByAnchor().filter((e)=>e.count >= threshold && e.surahId && e.anchorId).map((e)=>({\n            anchorId: e.anchorId,\n            label: e.label,\n            surahId: e.surahId,\n            count: e.count,\n            startVerse: e.startVerse,\n            endVerse: e.endVerse\n        }));\n}\nfunction clearAnchorIssues(surahId, anchorId) {\n    const remaining = getReviewErrors().filter((err)=>!(err.surahId === surahId && err.anchorId === anchorId));\n    if (false) {}\n    localStorage.setItem(STORAGE_KEYS.REVIEW_ERRORS, JSON.stringify(remaining));\n}\nfunction findAnchorForRange(surahId, startVerse, endVerse) {\n    const mindmap = getMindMap(surahId);\n    if (!startVerse || !endVerse) return undefined;\n    return mindmap.anchors.find((a)=>a.startVerse <= startVerse && a.endVerse >= endVerse);\n}\nfunction getCustomMutashabihat() {\n    return getFromCache(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, []);\n}\nfunction saveCustomMutashabih(mut) {\n    const all = getCustomMutashabihat();\n    const existingIdx = all.findIndex((m)=>m.id === mut.id);\n    if (existingIdx >= 0) {\n        all[existingIdx] = mut;\n    } else {\n        all.push(mut);\n    }\n    saveToCacheAndStore(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, all);\n}\nfunction deleteCustomMutashabih(id) {\n    const all = getCustomMutashabihat().filter((m)=>m.id !== id);\n    saveToCacheAndStore(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, all);\n}\nfunction getMutashabihatDecisions() {\n    return getFromCache(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, {});\n}\nfunction setMutashabihatDecision(absoluteAyah, decision, phraseId) {\n    const decisions = getMutashabihatDecisions();\n    const key = phraseId ? \"\".concat(absoluteAyah, \"-\").concat(phraseId) : absoluteAyah.toString();\n    decisions[key] = decision;\n    saveToCacheAndStore(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, decisions);\n}\nfunction resetMutashabihatDecisions(absoluteAyat) {\n    const decisions = getMutashabihatDecisions();\n    const keysToDelete = Object.keys(decisions).filter((key)=>{\n        const abs = parseInt(key.split(\"-\")[0], 10);\n        return absoluteAyat.includes(abs);\n    });\n    if (keysToDelete.length === 0) return;\n    keysToDelete.forEach((key)=>delete decisions[key]);\n    saveToCacheAndStore(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, decisions);\n}\nfunction bulkSetSurahStatus(surahIds, status) {\n    const settings = getSettings();\n    const allSurahs = _quranData__WEBPACK_IMPORTED_MODULE_0__.SURAHS;\n    surahIds.forEach((id)=>{\n        const surah = allSurahs.find((s)=>s.id === id);\n        if (!surah) return;\n        const surahKey = id.toString();\n        // Reset state for this surah first\n        delete settings.learnedVerses[surahKey];\n        settings.skippedSurahs = (settings.skippedSurahs || []).filter((sId)=>sId !== id);\n        if (status === \"learned\") {\n            const verseIds = Array.from({\n                length: surah.verseCount\n            }, (_, i)=>i + 1);\n            settings.learnedVerses[surahKey] = verseIds;\n        } else if (status === \"skipped\") {\n            settings.skippedSurahs = [\n                ...settings.skippedSurahs || [],\n                id\n            ];\n            pruneSurahArtifacts(id);\n        }\n    // 'new' status is already handled by the resets above\n    });\n    if (settings.skippedSurahs) {\n        settings.skippedSurahs.sort((a, b)=>a - b);\n    }\n    saveSettings(settings);\n}\nfunction pruneSurahArtifacts(surahId) {\n    // Remove memory nodes for this surah\n    const nodes = getMemoryNodes().filter((n)=>n.surahId !== surahId);\n    saveMemoryNodes(nodes);\n    // Remove surah mindmap\n    const maps = getMindMaps();\n    if (maps[surahId]) {\n        delete maps[surahId];\n        saveToCacheAndStore(STORAGE_KEYS.MINDMAPS, maps);\n    }\n    // Remove review errors\n    const remainingErrors = getReviewErrors().filter((err)=>err.surahId !== surahId);\n    saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, remainingErrors);\n}\nfunction isNodeSuspended(node, issues) {\n    if (!node.surahId) return false;\n    const relatedIssues = issues.filter((i)=>i.surahId === node.surahId);\n    if (relatedIssues.length === 0) return false;\n    if (node.type === \"mindmap\") return true;\n    if (node.type === \"verse\") {\n        const anchor = findAnchorForRange(node.surahId, node.startVerse, node.endVerse);\n        return anchor ? relatedIssues.some((i)=>i.anchorId === anchor.id) : false;\n    }\n    return false;\n}\nfunction exportBackup() {\n    return {\n        settings: getSettings(),\n        memoryNodes: getMemoryNodes(),\n        mindmaps: getMindMaps(),\n        partMindmaps: getPartMindMaps(),\n        listeningStats: getListeningStats(),\n        listeningProgress: getFromCache(STORAGE_KEYS.LISTENING_PROGRESS, {}),\n        reviewErrors: getReviewErrors(),\n        mutashabihatDecisions: getMutashabihatDecisions(),\n        customMutashabihat: getCustomMutashabihat(),\n        cycleStart: getCycleStart(),\n        listeningComplete: getFromCache(STORAGE_KEYS.LISTENING_COMPLETE, null),\n        exportedAt: new Date().toISOString()\n    };\n}\nfunction importBackup(data) {\n    if (data.settings) saveSettings(data.settings);\n    if (data.memoryNodes) saveMemoryNodes(data.memoryNodes);\n    if (data.mindmaps) {\n        saveToCacheAndStore(STORAGE_KEYS.MINDMAPS, data.mindmaps);\n    }\n    if (data.partMindmaps) {\n        saveToCacheAndStore(STORAGE_KEYS.PART_MINDMAPS, data.partMindmaps);\n    }\n    if (data.listeningStats) {\n        saveToCacheAndStore(STORAGE_KEYS.LISTENING_STATS, data.listeningStats);\n    }\n    if (data.listeningProgress) {\n        saveToCacheAndStore(STORAGE_KEYS.LISTENING_PROGRESS, data.listeningProgress);\n    }\n    if (data.reviewErrors) {\n        saveToCacheAndStore(STORAGE_KEYS.REVIEW_ERRORS, data.reviewErrors);\n    }\n    if (data.mutashabihatDecisions) {\n        saveToCacheAndStore(STORAGE_KEYS.MUTASHABIHAT_DECISIONS, data.mutashabihatDecisions);\n    }\n    if (data.customMutashabihat) {\n        saveToCacheAndStore(STORAGE_KEYS.CUSTOM_MUTASHABIHAT, data.customMutashabihat);\n    }\n    if (data.cycleStart) setCycleStart(data.cycleStart);\n    if (data.listeningComplete) saveToCacheAndStore(STORAGE_KEYS.LISTENING_COMPLETE, data.listeningComplete);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3RvcmFnZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBMkM7QUFDM0MsdURBQXVEO0FBQ3ZELDJDQUEyQztBQUVOO0FBRWM7QUFFbkQsMkNBQTJDO0FBQzNDLHFDQUFxQztBQUNyQywyQ0FBMkM7QUFFM0MsTUFBTUksY0FBYyxLQUFrQixHQUFjRCx1REFBV0EsQ0FBQyxnQkFBZ0IscUJBQXFCRSxDQUFTQTtBQUU5Rzs7Q0FFQyxHQUNELGVBQWVDO0lBQ1gsSUFBSSxNQUFrQixJQUFlLENBQUNGLGFBQWE7SUFFbkQsTUFBTUcsZ0JBQWdCO0lBQ3RCLElBQUlDLGFBQWFDLE9BQU8sQ0FBQ0YsZ0JBQWdCO0lBRXpDLEtBQUssTUFBTUcsT0FBT0MsT0FBT0MsTUFBTSxDQUFDQyxjQUFlO1FBQzNDLE1BQU1DLFFBQVFOLGFBQWFDLE9BQU8sQ0FBQ0M7UUFDbkMsSUFBSUksT0FBTztZQUNQLElBQUk7Z0JBQ0EsTUFBTVosK0NBQUdBLENBQUNRLEtBQUtLLEtBQUtDLEtBQUssQ0FBQ0YsUUFBUVY7WUFDdEMsRUFBRSxPQUFPYSxHQUFHO2dCQUNSQyxRQUFRQyxLQUFLLENBQUMsNEJBQWdDLE9BQUpULEtBQUksTUFBSU87WUFDdEQ7UUFDSjtJQUNKO0lBRUFULGFBQWFZLE9BQU8sQ0FBQ2IsZUFBZTtJQUNwQ1csUUFBUUcsR0FBRyxDQUFDO0FBQ2hCO0FBRUEsNEJBQTRCO0FBQzVCLElBQUksSUFBa0IsRUFBYTtJQUMvQmY7QUFDSjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1nQixlQUF1QyxDQUFDO0FBRTlDLGVBQWVDO0lBQ1gsSUFBSSxNQUFrQixJQUFlLENBQUNuQixhQUFhO0lBQ25ELEtBQUssTUFBTU0sT0FBT0MsT0FBT0MsTUFBTSxDQUFDQyxjQUFlO1FBQzNDUyxZQUFZLENBQUNaLElBQUksR0FBRyxNQUFNVCwr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S0FBS04scUJBQXFCLEVBQUU7UUFDNUJyTixvQkFBb0JkLGFBQWEwQixzQkFBc0IsRUFBRStNLEtBQUtOLHFCQUFxQjtJQUN2RjtJQUNBLElBQUlNLEtBQUtMLGtCQUFrQixFQUFFO1FBQ3pCdE4sb0JBQW9CZCxhQUFhMkIsbUJBQW1CLEVBQUU4TSxLQUFLTCxrQkFBa0I7SUFDakY7SUFDQSxJQUFJSyxLQUFLSixVQUFVLEVBQUVyRCxjQUFjeUQsS0FBS0osVUFBVTtJQUNsRCxJQUFJSSxLQUFLSCxpQkFBaUIsRUFBRXhOLG9CQUFvQmQsYUFBYXdCLGtCQUFrQixFQUFFaU4sS0FBS0gsaUJBQWlCO0FBQzNHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3RvcmFnZS50cz9hZmU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFN0b3JhZ2UgU2VydmljZSAtIFdpdGggUGFydCBNaW5kbWFwcyAmIFJldmlldyBFcnJvcnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW1wb3J0IHsgU1VSQUhTIH0gZnJvbSAnLi9xdXJhbkRhdGEnO1xuaW1wb3J0IHsgUXVyYW5QYXJ0LCBnZXRNYXR1cml0eVRocmVzaG9sZCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0LCBzZXQsIGNyZWF0ZVN0b3JlIH0gZnJvbSAnaWRiLWtleXZhbCc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFN0b3JhZ2UgRW5naW5lIE1pZ3JhdGlvbiAmIEhlbHBlcnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgY3VzdG9tU3RvcmUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGNyZWF0ZVN0b3JlKCdxdXJhbi1hcHAtZGInLCAncXVyYW4tYXBwLXN0b3JlJykgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogTWlncmF0aW9uIGhlbHBlciB0byBtb3ZlIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UgdG8gSW5kZXhlZERCIG9uY2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGVGcm9tTG9jYWxTdG9yYWdlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhY3VzdG9tU3RvcmUpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBtaWdyYXRpb25GbGFnID0gJ3F1cmFuLWFwcC1taWdyYXRlZC10by1pZGInO1xuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtaWdyYXRpb25GbGFnKSkgcmV0dXJuO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LnZhbHVlcyhTVE9SQUdFX0tFWVMpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNldChrZXksIEpTT04ucGFyc2UodmFsdWUpLCBjdXN0b21TdG9yZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTWlncmF0aW9uIGZhaWxlZCBmb3Iga2V5ICR7a2V5fTpgLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtaWdyYXRpb25GbGFnLCAndHJ1ZScpO1xuICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgbWlncmF0ZWQgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSB0byBJbmRleGVkREInKTtcbn1cblxuLy8gSW5pdGlhbCBtaWdyYXRpb24gdHJpZ2dlclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbWlncmF0ZUZyb21Mb2NhbFN0b3JhZ2UoKTtcbn1cblxuLyoqXG4gKiBHbG9iYWwgY2FjaGUgdG8ga2VlcCBzeW5jaHJvbm91cyBhY2Nlc3MgZm9yIGV4aXN0aW5nIFVJIHdoaWxlIHBlcnNpc3RpbmcgYXN5bmNocm9ub3VzbHkuXG4gKiBUaGlzIGVuc3VyZXMgdGhlIFVJIHJlbWFpbnMgc25hcHB5IHdoaWxlIGRhdGEgaXMgc2FmZWx5IHN0b3JlZCBpbiBJbmRleGVkREIuXG4gKi9cbmNvbnN0IHN0b3JhZ2VDYWNoZTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG5hc3luYyBmdW5jdGlvbiBsb2FkSW50b0NhY2hlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhY3VzdG9tU3RvcmUpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QudmFsdWVzKFNUT1JBR0VfS0VZUykpIHtcbiAgICAgICAgc3RvcmFnZUNhY2hlW2tleV0gPSBhd2FpdCBnZXQoa2V5LCBjdXN0b21TdG9yZSk7XG4gICAgfVxufVxuXG4vLyBTdGFydCBsb2FkaW5nIGNhY2hlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2FkSW50b0NhY2hlKCk7XG59XG5cbmZ1bmN0aW9uIGdldEZyb21DYWNoZTxUPihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBUKTogVCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIGNvbnN0IGNhY2hlZCA9IHN0b3JhZ2VDYWNoZVtrZXldO1xuICAgIHJldHVybiBjYWNoZWQgIT09IHVuZGVmaW5lZCA/IGNhY2hlZCA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gc2F2ZVRvQ2FjaGVBbmRTdG9yZShrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIHN0b3JhZ2VDYWNoZVtrZXldID0gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGN1c3RvbVN0b3JlKSB7XG4gICAgICAgIHNldChrZXksIHZhbHVlLCBjdXN0b21TdG9yZSkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwZXJzaXN0ICR7a2V5fTpgLCBlcnIpKTtcbiAgICB9XG59XG5cbmNvbnN0IFNUT1JBR0VfS0VZUyA9IHtcbiAgICBTRVRUSU5HUzogJ3F1cmFuLWFwcC1zZXR0aW5ncycsXG4gICAgTUVNT1JZX05PREVTOiAncXVyYW4tYXBwLW1lbW9yeS1ub2RlcycsXG4gICAgTUlORE1BUFM6ICdxdXJhbi1hcHAtbWluZG1hcHMnLFxuICAgIFBBUlRfTUlORE1BUFM6ICdxdXJhbi1hcHAtcGFydC1taW5kbWFwcycsXG4gICAgTElTVEVOSU5HX1BST0dSRVNTOiAncXVyYW4tYXBwLWxpc3RlbmluZy1wcm9ncmVzcycsXG4gICAgTElTVEVOSU5HX1NUQVRTOiAncXVyYW4tYXBwLWxpc3RlbmluZy1zdGF0cycsXG4gICAgQ1lDTEVfU1RBUlQ6ICdxdXJhbi1hcHAtY3ljbGUtc3RhcnQnLFxuICAgIExJU1RFTklOR19DT01QTEVURTogJ3F1cmFuLWFwcC1saXN0ZW5pbmctY29tcGxldGUnLFxuICAgIFJFVklFV19FUlJPUlM6ICdxdXJhbi1hcHAtcmV2aWV3LWVycm9ycycsXG4gICAgTVVUQVNIQUJJSEFUX0RFQ0lTSU9OUzogJ3F1cmFuLWFwcC1tdXRhc2hhYmloYXQtZGVjaXNpb25zJyxcbiAgICBDVVNUT01fTVVUQVNIQUJJSEFUOiAncXVyYW4tYXBwLWN1c3RvbS1tdXRhc2hhYmloYXQnLFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2V0dGluZ3Ncbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBTZXR0aW5ncyB7XG4gICAgY29tcGxldGlvbkRheXM6IG51bWJlcjtcbiAgICBhY3RpdmVQYXJ0OiBRdXJhblBhcnQ7XG4gICAgbGVhcm5lZFZlcnNlczogeyBbc3VyYWhJZDogc3RyaW5nXTogbnVtYmVyW10gfTtcbiAgICBza2lwcGVkU3VyYWhzPzogbnVtYmVyW107XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEFwcFNldHRpbmdzID0ge1xuICAgIGNvbXBsZXRpb25EYXlzOiAzMCxcbiAgICBhY3RpdmVQYXJ0OiA0LFxuICAgIGxlYXJuZWRWZXJzZXM6IHt9LFxuICAgIHNraXBwZWRTdXJhaHM6IFtdLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNldHRpbmdzKCk6IEFwcFNldHRpbmdzIHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5TRVRUSU5HUywgREVGQVVMVF9TRVRUSU5HUyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlU2V0dGluZ3Moc2V0dGluZ3M6IEFwcFNldHRpbmdzKTogdm9pZCB7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuU0VUVElOR1MsIHNldHRpbmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVNldHRpbmc8SyBleHRlbmRzIGtleW9mIEFwcFNldHRpbmdzPihrZXk6IEssIHZhbHVlOiBBcHBTZXR0aW5nc1tLXSk6IHZvaWQge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICBzZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgc2F2ZVNldHRpbmdzKHNldHRpbmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VyYWhTa2lwcGVkKHN1cmFoSWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICByZXR1cm4gc2V0dGluZ3Muc2tpcHBlZFN1cmFocz8uaW5jbHVkZXMoc3VyYWhJZCkgfHwgZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVTdXJhaFNraXBwZWQoc3VyYWhJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBuZXcgU2V0KHNldHRpbmdzLnNraXBwZWRTdXJhaHMgfHwgW10pO1xuICAgIGlmIChjdXJyZW50LmhhcyhzdXJhaElkKSkge1xuICAgICAgICBjdXJyZW50LmRlbGV0ZShzdXJhaElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LmFkZChzdXJhaElkKTtcbiAgICAgICAgLy8gQWxzbyByZW1vdmUgYW55IGxlYXJuZWQgZGF0YSBmb3IgdGhpcyBzdXJhaFxuICAgICAgICBpZiAoc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaElkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhJZF07XG4gICAgICAgIH1cbiAgICAgICAgcHJ1bmVTdXJhaEFydGlmYWN0cyhzdXJhaElkKTtcbiAgICB9XG4gICAgc2V0dGluZ3Muc2tpcHBlZFN1cmFocyA9IEFycmF5LmZyb20oY3VycmVudCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncyk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExlYXJuZWQgVmVyc2VzIEhlbHBlcnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2VMZWFybmVkKHN1cmFoSWQ6IG51bWJlciwgYXlhaElkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgcmV0dXJuIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhJZF0/LmluY2x1ZGVzKGF5YWhJZCkgfHwgZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVWZXJzZUxlYXJuZWQoc3VyYWhJZDogbnVtYmVyLCBheWFoSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBzdXJhaEtleSA9IHN1cmFoSWQudG9TdHJpbmcoKTtcbiAgICBjb25zdCBjdXJyZW50ID0gc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV0gfHwgW107XG5cbiAgICBpZiAoY3VycmVudC5pbmNsdWRlcyhheWFoSWQpKSB7XG4gICAgICAgIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldID0gY3VycmVudC5maWx0ZXIodiA9PiB2ICE9PSBheWFoSWQpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0aW5ncy5sZWFybmVkVmVyc2VzW3N1cmFoS2V5XSA9IFsuLi5jdXJyZW50LCBheWFoSWRdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICB9XG5cbiAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIHN5bmNNZW1vcnlOb2Rlc1dpdGhMZWFybmVkKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVTdXJhaExlYXJuZWQoc3VyYWhJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IHN1cmFoID0gU1VSQUhTLmZpbmQocyA9PiBzLmlkID09PSBzdXJhaElkKTtcbiAgICBpZiAoIXN1cmFoKSByZXR1cm47XG5cbiAgICBjb25zdCBzdXJhaEtleSA9IHN1cmFoSWQudG9TdHJpbmcoKTtcbiAgICBjb25zdCBjdXJyZW50ID0gc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaEtleV0gfHwgW107XG5cbiAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IHN1cmFoLnZlcnNlQ291bnQpIHtcbiAgICAgICAgZGVsZXRlIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc3VyYWgudmVyc2VDb3VudCB9LCAoXywgaSkgPT4gaSArIDEpO1xuICAgIH1cblxuICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgc3luY01lbW9yeU5vZGVzV2l0aExlYXJuZWQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1cmFoTGVhcm5lZFN0YXR1cyhzdXJhaElkOiBudW1iZXIpOiB7IGxlYXJuZWQ6IG51bWJlcjsgdG90YWw6IG51bWJlciB9IHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgY29uc3Qgc3VyYWggPSBTVVJBSFMuZmluZChzID0+IHMuaWQgPT09IHN1cmFoSWQpO1xuICAgIGlmICghc3VyYWgpIHJldHVybiB7IGxlYXJuZWQ6IDAsIHRvdGFsOiAwIH07XG5cbiAgICBjb25zdCBsZWFybmVkID0gc2V0dGluZ3MubGVhcm5lZFZlcnNlc1tzdXJhaElkXT8ubGVuZ3RoIHx8IDA7XG4gICAgcmV0dXJuIHsgbGVhcm5lZCwgdG90YWw6IHN1cmFoLnZlcnNlQ291bnQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvdGFsTGVhcm5lZFZlcnNlcygpOiBudW1iZXIge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzZXR0aW5ncy5sZWFybmVkVmVyc2VzKS5yZWR1Y2UoKHN1bSwgdmVyc2VzKSA9PiBzdW0gKyB2ZXJzZXMubGVuZ3RoLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlYXJuZWRWZXJzZXNJblBhcnQocGFydDogUXVyYW5QYXJ0KTogeyBzdXJhaElkOiBudW1iZXI7IGF5YWhJZDogbnVtYmVyIH1bXSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IHJlc3VsdDogeyBzdXJhaElkOiBudW1iZXI7IGF5YWhJZDogbnVtYmVyIH1bXSA9IFtdO1xuXG4gICAgU1VSQUhTLmZpbHRlcihzID0+IHMucGFydCA9PT0gcGFydCkuZm9yRWFjaChzdXJhaCA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNlcyA9IHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWguaWRdIHx8IFtdO1xuICAgICAgICB2ZXJzZXMuZm9yRWFjaChheWFoSWQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdXJhaElkOiBzdXJhaC5pZCwgYXlhaElkIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1lbW9yeSBOb2RlcyAoU00tMilcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBTTTJTdGF0ZSB7XG4gICAgaW50ZXJ2YWw6IG51bWJlcjtcbiAgICByZXBldGl0aW9uOiBudW1iZXI7XG4gICAgZWFzZUZhY3RvcjogbnVtYmVyO1xuICAgIGR1ZURhdGU6IHN0cmluZztcbiAgICBsYXN0UmV2aWV3OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5Tm9kZSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0eXBlOiAndmVyc2UnIHwgJ21pbmRtYXAnIHwgJ3BhcnRfbWluZG1hcCc7XG4gICAgc3VyYWhJZD86IG51bWJlcjtcbiAgICBwYXJ0SWQ/OiBRdXJhblBhcnQ7XG4gICAgc3RhcnRWZXJzZT86IG51bWJlcjtcbiAgICBlbmRWZXJzZT86IG51bWJlcjtcbiAgICBzY2hlZHVsZXI6IFNNMlN0YXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVtb3J5Tm9kZXMoKTogTWVtb3J5Tm9kZVtdIHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5NRU1PUllfTk9ERVMsIFtdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVNZW1vcnlOb2Rlcyhub2RlczogTWVtb3J5Tm9kZVtdKTogdm9pZCB7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTUVNT1JZX05PREVTLCBub2Rlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREdWVOb2RlcygpOiBNZW1vcnlOb2RlW10ge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IHNraXBzID0gbmV3IFNldChzZXR0aW5ncy5za2lwcGVkU3VyYWhzIHx8IFtdKTtcbiAgICBjb25zdCBzdXNwZW5kZWQgPSBnZXRTdXNwZW5kZWRBbmNob3JzKCk7XG5cbiAgICByZXR1cm4gZ2V0TWVtb3J5Tm9kZXMoKVxuICAgICAgICAuZmlsdGVyKG4gPT4gbi5zY2hlZHVsZXIuZHVlRGF0ZSA8PSB0b2RheSlcbiAgICAgICAgLmZpbHRlcihuID0+ICFuLnN1cmFoSWQgfHwgIXNraXBzLmhhcyhuLnN1cmFoSWQpKVxuICAgICAgICAuZmlsdGVyKG4gPT4gIWlzTm9kZVN1c3BlbmRlZChuLCBzdXNwZW5kZWQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1lbW9yeU5vZGUobm9kZTogTWVtb3J5Tm9kZSk6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gZ2V0TWVtb3J5Tm9kZXMoKTtcbiAgICBjb25zdCBpbmRleCA9IG5vZGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIG5vZGVzW2luZGV4XSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgc2F2ZU1lbW9yeU5vZGVzKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTmV3U2NoZWR1bGVyKCk6IFNNMlN0YXRlIHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVydmFsOiAwLFxuICAgICAgICByZXBldGl0aW9uOiAwLFxuICAgICAgICBlYXNlRmFjdG9yOiAyLjUsXG4gICAgICAgIGR1ZURhdGU6IHRvZGF5LFxuICAgICAgICBsYXN0UmV2aWV3OiAnJyxcbiAgICB9O1xufVxuXG4vLyBTeW5jIG1lbW9yeSBub2RlcyB3aXRoIGxlYXJuZWQgdmVyc2VzIC0gY3JlYXRlIG5vZGVzIGZvciBsZWFybmVkIHZlcnNlc1xuZXhwb3J0IGZ1bmN0aW9uIHN5bmNNZW1vcnlOb2Rlc1dpdGhMZWFybmVkKGZvcmNlRnVsbFJlc2V0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgY29uc3Qgbm9kZXMgPSBmb3JjZUZ1bGxSZXNldCA/IFtdIDogZ2V0TWVtb3J5Tm9kZXMoKTtcblxuICAgIC8vIEdyb3VwIHZlcnNlcyBpbnRvIHNlZ21lbnRzIG9mIDVcbiAgICBPYmplY3QuZW50cmllcyhzZXR0aW5ncy5sZWFybmVkVmVyc2VzKS5mb3JFYWNoKChbc3VyYWhJZFN0ciwgdmVyc2VzXSkgPT4ge1xuICAgICAgICBjb25zdCBzdXJhaElkID0gcGFyc2VJbnQoc3VyYWhJZFN0cik7XG4gICAgICAgIGlmICh2ZXJzZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ3JlYXRlIHNlZ21lbnRzIG9mIDUgdmVyc2VzXG4gICAgICAgIGNvbnN0IHNvcnRlZFZlcnNlcyA9IFsuLi52ZXJzZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgbGV0IHNlZ21lbnRTdGFydCA9IHNvcnRlZFZlcnNlc1swXTtcbiAgICAgICAgbGV0IHNlZ21lbnRFbmQgPSBzZWdtZW50U3RhcnQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc29ydGVkVmVyc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpc0NvbnRpZ3VvdXMgPSBpIDwgc29ydGVkVmVyc2VzLmxlbmd0aCAmJiBzb3J0ZWRWZXJzZXNbaV0gPT09IHNlZ21lbnRFbmQgKyAxO1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSBzZWdtZW50RW5kIC0gc2VnbWVudFN0YXJ0ICsgMTtcblxuICAgICAgICAgICAgaWYgKCFpc0NvbnRpZ3VvdXMgfHwgc2VnbWVudFNpemUgPj0gNSB8fCBpID09PSBzb3J0ZWRWZXJzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5vZGUgZm9yIHRoaXMgc2VnbWVudCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gYHZlcnNlLSR7c3VyYWhJZH0tJHtzZWdtZW50U3RhcnR9LSR7c2VnbWVudEVuZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IG5vZGVzLnNvbWUobiA9PiBuLmlkID09PSBub2RlSWQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghZXhpc3RzIHx8IGZvcmNlRnVsbFJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGU6IE1lbW9yeU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cmFoSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFZlcnNlOiBzZWdtZW50U3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRWZXJzZTogc2VnbWVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcjogY3JlYXRlTmV3U2NoZWR1bGVyKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlRnVsbFJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHNvcnRlZFZlcnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudFN0YXJ0ID0gc29ydGVkVmVyc2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50RW5kID0gc2VnbWVudFN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudEVuZCA9IHNvcnRlZFZlcnNlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGZvcmNlRnVsbFJlc2V0KSB7XG4gICAgICAgIC8vIEFsc28gc3luYyBtaW5kbWFwc1xuICAgICAgICBjb25zdCBtaW5kbWFwcyA9IGdldE1pbmRNYXBzKCk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobWluZG1hcHMpLmZvckVhY2gobW0gPT4ge1xuICAgICAgICAgICAgaWYgKG1tLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBtaW5kbWFwLSR7bW0uc3VyYWhJZH1gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWluZG1hcCcsXG4gICAgICAgICAgICAgICAgICAgIHN1cmFoSWQ6IG1tLnN1cmFoSWQsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcjogY3JlYXRlTmV3U2NoZWR1bGVyKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFsc28gc3luYyBwYXJ0IG1pbmRtYXBzXG4gICAgICAgIGNvbnN0IHBhcnRNaW5kbWFwcyA9IGdldFBhcnRNaW5kTWFwcygpO1xuICAgICAgICBPYmplY3QudmFsdWVzKHBhcnRNaW5kbWFwcykuZm9yRWFjaChwbW0gPT4ge1xuICAgICAgICAgICAgaWYgKHBtbS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBgcGFydC1taW5kbWFwLSR7cG1tLnBhcnRJZH1gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGFydF9taW5kbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgcGFydElkOiBwbW0ucGFydElkLFxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI6IGNyZWF0ZU5ld1NjaGVkdWxlcigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzYXZlTWVtb3J5Tm9kZXMobm9kZXMpO1xufVxuXG4vLyBTTS0yIEFsZ29yaXRobVxuZXhwb3J0IGZ1bmN0aW9uIHNtMihncmFkZTogbnVtYmVyLCBzdGF0ZTogU00yU3RhdGUpOiBTTTJTdGF0ZSB7XG4gICAgbGV0IHsgaW50ZXJ2YWwsIHJlcGV0aXRpb24sIGVhc2VGYWN0b3IgfSA9IHN0YXRlO1xuXG4gICAgaWYgKGdyYWRlIDwgMykge1xuICAgICAgICByZXBldGl0aW9uID0gMDtcbiAgICAgICAgaW50ZXJ2YWwgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXBldGl0aW9uID09PSAwKSBpbnRlcnZhbCA9IDE7XG4gICAgICAgIGVsc2UgaWYgKHJlcGV0aXRpb24gPT09IDEpIGludGVydmFsID0gNjtcbiAgICAgICAgZWxzZSBpbnRlcnZhbCA9IE1hdGgucm91bmQoaW50ZXJ2YWwgKiBlYXNlRmFjdG9yKTtcbiAgICAgICAgcmVwZXRpdGlvbisrO1xuICAgIH1cblxuICAgIGVhc2VGYWN0b3IgPSBNYXRoLm1heCgxLjMsIGVhc2VGYWN0b3IgKyAoMC4xIC0gKDUgLSBncmFkZSkgKiAoMC4wOCArICg1IC0gZ3JhZGUpICogMC4wMikpKTtcblxuICAgIGNvbnN0IGR1ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGR1ZURhdGUuc2V0RGF0ZShkdWVEYXRlLmdldERhdGUoKSArIGludGVydmFsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVydmFsLFxuICAgICAgICByZXBldGl0aW9uLFxuICAgICAgICBlYXNlRmFjdG9yOiBNYXRoLnJvdW5kKGVhc2VGYWN0b3IgKiAxMDApIC8gMTAwLFxuICAgICAgICBkdWVEYXRlOiBkdWVEYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgbGFzdFJldmlldzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc3Rwb25lTm9kZShub2RlOiBNZW1vcnlOb2RlKTogTWVtb3J5Tm9kZSB7XG4gICAgY29uc3QgdG9tb3Jyb3cgPSBuZXcgRGF0ZSgpO1xuICAgIHRvbW9ycm93LnNldERhdGUodG9tb3Jyb3cuZ2V0RGF0ZSgpICsgMSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgc2NoZWR1bGVyOiB7XG4gICAgICAgICAgICAuLi5ub2RlLnNjaGVkdWxlcixcbiAgICAgICAgICAgIGR1ZURhdGU6IHRvbW9ycm93LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgIGxhc3RSZXZpZXc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTWluZG1hcHMgKHBlciBzdXJhaClcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBBbmNob3Ige1xuICAgIGlkOiBzdHJpbmc7XG4gICAgc3RhcnRWZXJzZTogbnVtYmVyO1xuICAgIGVuZFZlcnNlOiBudW1iZXI7XG4gICAgbGFiZWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNaW5kTWFwIHtcbiAgICBzdXJhaElkOiBudW1iZXI7XG4gICAgaW1hZ2VVcmw6IHN0cmluZyB8IG51bGw7XG4gICAgYW5jaG9yczogQW5jaG9yW107XG4gICAgaXNDb21wbGV0ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbmRNYXBzKCk6IHsgW3N1cmFoSWQ6IHN0cmluZ106IE1pbmRNYXAgfSB7XG4gICAgcmV0dXJuIGdldEZyb21DYWNoZShTVE9SQUdFX0tFWVMuTUlORE1BUFMsIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbmRNYXAoc3VyYWhJZDogbnVtYmVyKTogTWluZE1hcCB7XG4gICAgY29uc3QgbWFwcyA9IGdldE1pbmRNYXBzKCk7XG4gICAgcmV0dXJuIG1hcHNbc3VyYWhJZF0gfHwgeyBzdXJhaElkLCBpbWFnZVVybDogbnVsbCwgYW5jaG9yczogW10sIGlzQ29tcGxldGU6IGZhbHNlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlTWluZE1hcChtaW5kbWFwOiBNaW5kTWFwKTogdm9pZCB7XG4gICAgY29uc3QgbWFwcyA9IGdldE1pbmRNYXBzKCk7XG4gICAgbWFwc1ttaW5kbWFwLnN1cmFoSWRdID0gbWluZG1hcDtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5NSU5ETUFQUywgbWFwcyk7XG5cbiAgICAvLyBDcmVhdGUvdXBkYXRlIG1lbW9yeSBub2RlIGZvciBtaW5kbWFwIGlmIGNvbXBsZXRlXG4gICAgaWYgKG1pbmRtYXAuaXNDb21wbGV0ZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IGdldE1lbW9yeU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IGBtaW5kbWFwLSR7bWluZG1hcC5zdXJhaElkfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG5vZGVzLnNvbWUobiA9PiBuLmlkID09PSBub2RlSWQpO1xuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnbWluZG1hcCcsXG4gICAgICAgICAgICAgICAgc3VyYWhJZDogbWluZG1hcC5zdXJhaElkLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlcjogY3JlYXRlTmV3U2NoZWR1bGVyKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNhdmVNZW1vcnlOb2Rlcyhub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBhcnQgTWluZG1hcHMgKGludGVyLXN1cmFoIGNvbm5lY3Rpb25zKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRNaW5kTWFwIHtcbiAgICBwYXJ0SWQ6IFF1cmFuUGFydDtcbiAgICBpbWFnZVVybDogc3RyaW5nIHwgbnVsbDtcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIGlzQ29tcGxldGU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJ0TWluZE1hcHMoKTogeyBbcGFydElkOiBzdHJpbmddOiBQYXJ0TWluZE1hcCB9IHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5QQVJUX01JTkRNQVBTLCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJ0TWluZE1hcChwYXJ0SWQ6IFF1cmFuUGFydCk6IFBhcnRNaW5kTWFwIHtcbiAgICBjb25zdCBtYXBzID0gZ2V0UGFydE1pbmRNYXBzKCk7XG4gICAgcmV0dXJuIG1hcHNbcGFydElkXSB8fCB7IHBhcnRJZCwgaW1hZ2VVcmw6IG51bGwsIGRlc2NyaXB0aW9uOiAnJywgaXNDb21wbGV0ZTogZmFsc2UgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVQYXJ0TWluZE1hcChtaW5kbWFwOiBQYXJ0TWluZE1hcCk6IHZvaWQge1xuICAgIGNvbnN0IG1hcHMgPSBnZXRQYXJ0TWluZE1hcHMoKTtcbiAgICBtYXBzW21pbmRtYXAucGFydElkXSA9IG1pbmRtYXA7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuUEFSVF9NSU5ETUFQUywgbWFwcyk7XG5cbiAgICAvLyBDcmVhdGUgbWVtb3J5IG5vZGUgZm9yIHBhcnQgbWluZG1hcCBpZiBjb21wbGV0ZVxuICAgIGlmIChtaW5kbWFwLmlzQ29tcGxldGUpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXRNZW1vcnlOb2RlcygpO1xuICAgICAgICBjb25zdCBub2RlSWQgPSBgcGFydC1taW5kbWFwLSR7bWluZG1hcC5wYXJ0SWR9YDtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gbm9kZXMuc29tZShuID0+IG4uaWQgPT09IG5vZGVJZCk7XG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJ0X21pbmRtYXAnLFxuICAgICAgICAgICAgICAgIHBhcnRJZDogbWluZG1hcC5wYXJ0SWQsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyOiBjcmVhdGVOZXdTY2hlZHVsZXIoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2F2ZU1lbW9yeU5vZGVzKG5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTGlzdGVuaW5nIFN0YXRzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuaW5nU3RhdHMge1xuICAgIHN1cmFoSWQ6IG51bWJlcjtcbiAgICB0b3RhbE1pbnV0ZXM6IG51bWJlcjtcbiAgICBsYXN0TGlzdGVuZWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5pbmdQcm9ncmVzcyB7XG4gICAgcGFydElkOiBRdXJhblBhcnQ7XG4gICAgY3VycmVudFZlcnNlSW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExpc3RlbmluZ1Byb2dyZXNzKHBhcnRJZDogUXVyYW5QYXJ0KTogTGlzdGVuaW5nUHJvZ3Jlc3Mge1xuICAgIGNvbnN0IG1hcCA9IGdldEZyb21DYWNoZTxSZWNvcmQ8c3RyaW5nLCBMaXN0ZW5pbmdQcm9ncmVzcz4+KFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfUFJPR1JFU1MsIHt9KTtcbiAgICByZXR1cm4gbWFwW3BhcnRJZF0gfHwgeyBwYXJ0SWQsIGN1cnJlbnRWZXJzZUluZGV4OiAwIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlTGlzdGVuaW5nUHJvZ3Jlc3MocGFydElkOiBRdXJhblBhcnQsIGN1cnJlbnRWZXJzZUluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBtYXAgPSBnZXRGcm9tQ2FjaGU8UmVjb3JkPHN0cmluZywgTGlzdGVuaW5nUHJvZ3Jlc3M+PihTVE9SQUdFX0tFWVMuTElTVEVOSU5HX1BST0dSRVNTLCB7fSk7XG4gICAgbWFwW3BhcnRJZF0gPSB7IHBhcnRJZCwgY3VycmVudFZlcnNlSW5kZXggfTtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfUFJPR1JFU1MsIG1hcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXN0ZW5pbmdTdGF0cygpOiB7IFtzdXJhaElkOiBzdHJpbmddOiBMaXN0ZW5pbmdTdGF0cyB9IHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfU1RBVFMsIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExpc3RlbmluZ1N0YXRzRm9yU3VyYWgoc3VyYWhJZDogbnVtYmVyKTogTGlzdGVuaW5nU3RhdHMge1xuICAgIGNvbnN0IHN0YXRzID0gZ2V0TGlzdGVuaW5nU3RhdHMoKTtcbiAgICByZXR1cm4gc3RhdHNbc3VyYWhJZF0gfHwgeyBzdXJhaElkLCB0b3RhbE1pbnV0ZXM6IDAsIGxhc3RMaXN0ZW5lZDogJycgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExpc3RlbmluZ1RpbWUoc3VyYWhJZDogbnVtYmVyLCBtaW51dGVzOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0cyA9IGdldExpc3RlbmluZ1N0YXRzKCk7XG4gICAgY29uc3QgY3VycmVudCA9IHN0YXRzW3N1cmFoSWRdIHx8IHsgc3VyYWhJZCwgdG90YWxNaW51dGVzOiAwLCBsYXN0TGlzdGVuZWQ6ICcnIH07XG4gICAgY3VycmVudC50b3RhbE1pbnV0ZXMgKz0gbWludXRlcztcbiAgICBjdXJyZW50Lmxhc3RMaXN0ZW5lZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBzdGF0c1tzdXJhaElkXSA9IGN1cnJlbnQ7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTElTVEVOSU5HX1NUQVRTLCBzdGF0cyk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExpc3RlbmluZyBDb21wbGV0ZSBUcmFja2luZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdGVuaW5nQ29tcGxldGVkVG9kYXkoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc3RvcmVkID0gZ2V0RnJvbUNhY2hlPHN0cmluZyB8IG51bGw+KFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfQ09NUExFVEUsIG51bGwpO1xuICAgIGlmICghc3RvcmVkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICByZXR1cm4gc3RvcmVkID09PSB0b2RheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtMaXN0ZW5pbmdDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLkxJU1RFTklOR19DT01QTEVURSwgdG9kYXkpO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSZXZpZXcgRXJyb3JzIFRyYWNraW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmV2aWV3RXJyb3Ige1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBzdHJpbmc7XG4gICAgbm9kZUlkOiBzdHJpbmc7XG4gICAgbm9kZVR5cGU6ICd2ZXJzZScgfCAnbWluZG1hcCcgfCAncGFydF9taW5kbWFwJztcbiAgICBzdXJhaElkPzogbnVtYmVyO1xuICAgIHBhcnRJZD86IFF1cmFuUGFydDtcbiAgICBzdGFydFZlcnNlPzogbnVtYmVyO1xuICAgIGVuZFZlcnNlPzogbnVtYmVyO1xuICAgIGdyYWRlOiBudW1iZXI7XG4gICAgYW5jaG9yTGFiZWw/OiBzdHJpbmc7XG4gICAgYW5jaG9ySWQ/OiBzdHJpbmc7XG4gICAgYWJzb2x1dGVBeWFoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmV2aWV3RXJyb3JzKCk6IFJldmlld0Vycm9yW10ge1xuICAgIHJldHVybiBnZXRGcm9tQ2FjaGUoU1RPUkFHRV9LRVlTLlJFVklFV19FUlJPUlMsIFtdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVSZXZpZXdFcnJvcihlcnJvcjogUmV2aWV3RXJyb3IpOiB2b2lkIHtcbiAgICBjb25zdCBlcnJvcnMgPSBnZXRSZXZpZXdFcnJvcnMoKTtcbiAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAwIGVycm9yc1xuICAgIGNvbnN0IHRyaW1tZWQgPSBlcnJvcnMuc2xpY2UoLTEwMCk7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuUkVWSUVXX0VSUk9SUywgdHJpbW1lZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSZXZpZXdFcnJvcihpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgZXJyb3JzID0gZ2V0UmV2aWV3RXJyb3JzKCk7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZXJyb3JzLmZpbHRlcihlID0+IGUuaWQgIT09IGlkKTtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5SRVZJRVdfRVJST1JTLCByZW1haW5pbmcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JzQnlBbmNob3IoKTogeyBsYWJlbDogc3RyaW5nOyBjb3VudDogbnVtYmVyOyBzdXJhaElkPzogbnVtYmVyOyBhbmNob3JJZD86IHN0cmluZzsgc3RhcnRWZXJzZT86IG51bWJlcjsgZW5kVmVyc2U/OiBudW1iZXIgfVtdIHtcbiAgICBjb25zdCBlcnJvcnMgPSBnZXRSZXZpZXdFcnJvcnMoKTtcbiAgICBjb25zdCBtaW5kbWFwcyA9IGdldE1pbmRNYXBzKCk7XG4gICAgY29uc3QgYW5jaG9yQ291bnRzOiB7IFtrZXk6IHN0cmluZ106IHsgbGFiZWw6IHN0cmluZzsgY291bnQ6IG51bWJlcjsgc3VyYWhJZD86IG51bWJlcjsgYW5jaG9ySWQ/OiBzdHJpbmc7IHN0YXJ0VmVyc2U/OiBudW1iZXI7IGVuZFZlcnNlPzogbnVtYmVyIH0gfSA9IHt9O1xuXG4gICAgZXJyb3JzLmZpbHRlcihlID0+IGUuZ3JhZGUgPCAzKS5mb3JFYWNoKGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yLnN1cmFoSWQgJiYgZXJyb3Iuc3RhcnRWZXJzZSAmJiBlcnJvci5lbmRWZXJzZSkge1xuICAgICAgICAgICAgY29uc3QgbWluZG1hcCA9IG1pbmRtYXBzW2Vycm9yLnN1cmFoSWRdO1xuICAgICAgICAgICAgaWYgKG1pbmRtYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBtaW5kbWFwLmFuY2hvcnMuZmluZChhID0+XG4gICAgICAgICAgICAgICAgICAgIGEuc3RhcnRWZXJzZSA8PSBlcnJvci5zdGFydFZlcnNlISAmJiBhLmVuZFZlcnNlID49IGVycm9yLmVuZFZlcnNlIVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtlcnJvci5zdXJhaElkfS0ke2FuY2hvci5pZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuY2hvckNvdW50c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JDb3VudHNba2V5XSA9IHsgbGFiZWw6IGFuY2hvci5sYWJlbCwgY291bnQ6IDAsIHN1cmFoSWQ6IGVycm9yLnN1cmFoSWQsIGFuY2hvcklkOiBhbmNob3IuaWQsIHN0YXJ0VmVyc2U6IGFuY2hvci5zdGFydFZlcnNlLCBlbmRWZXJzZTogYW5jaG9yLmVuZFZlcnNlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yQ291bnRzW2tleV0uY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFuY2hvckNvdW50cykuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDeWNsZSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDeWNsZVN0YXJ0KCk6IHN0cmluZyB7XG4gICAgbGV0IHN0b3JlZCA9IGdldEZyb21DYWNoZTxzdHJpbmcgfCBudWxsPihTVE9SQUdFX0tFWVMuQ1lDTEVfU1RBUlQsIG51bGwpO1xuICAgIGlmICghc3RvcmVkKSB7XG4gICAgICAgIHN0b3JlZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgICAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5DWUNMRV9TVEFSVCwgc3RvcmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEN5Y2xlU3RhcnQoZGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuQ1lDTEVfU1RBUlQsIGRhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudERheUluQ3ljbGUoKTogbnVtYmVyIHtcbiAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKGdldEN5Y2xlU3RhcnQoKSk7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmZsb29yKCh0b2RheS5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgcmV0dXJuIGRpZmYgJSBzZXR0aW5ncy5jb21wbGV0aW9uRGF5cztcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQmFja3VwICYgUmVzdG9yZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2t1cERhdGEge1xuICAgIHNldHRpbmdzOiBBcHBTZXR0aW5ncztcbiAgICBtZW1vcnlOb2RlczogTWVtb3J5Tm9kZVtdO1xuICAgIG1pbmRtYXBzOiB7IFtzdXJhaElkOiBzdHJpbmddOiBNaW5kTWFwIH07XG4gICAgcGFydE1pbmRtYXBzOiB7IFtwYXJ0SWQ6IHN0cmluZ106IFBhcnRNaW5kTWFwIH07XG4gICAgbGlzdGVuaW5nU3RhdHM6IHsgW3N1cmFoSWQ6IHN0cmluZ106IExpc3RlbmluZ1N0YXRzIH07XG4gICAgcmV2aWV3RXJyb3JzOiBSZXZpZXdFcnJvcltdO1xuICAgIGN5Y2xlU3RhcnQ6IHN0cmluZztcbiAgICBleHBvcnRlZEF0OiBzdHJpbmc7XG59XG5cbi8vIE1hdHVyaXR5IExldmVsc1xuZXhwb3J0IHR5cGUgTWF0dXJpdHlMZXZlbCA9ICdyZXNldCcgfCAnbWVkaXVtJyB8ICdzdHJvbmcnIHwgJ21hc3RlcmVkJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFN1cmFoTWF0dXJpdHkoc3VyYWhJZDogbnVtYmVyLCBsZXZlbDogTWF0dXJpdHlMZXZlbCk6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gZ2V0TWVtb3J5Tm9kZXMoKTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgY29uc3QgdXBkYXRlZE5vZGVzID0gbm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5zdXJhaElkICE9PSBzdXJhaElkIHx8IChub2RlLnR5cGUgIT09ICd2ZXJzZScgJiYgbm9kZS50eXBlICE9PSAnbWluZG1hcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IDE7XG4gICAgICAgIGxldCBlZmFjdG9yID0gMi41O1xuXG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgIGludGVydmFsID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAgICAgIGludGVydmFsID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXN0ZXJlZCc6XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSA5MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBqaXR0ZXI6ICsvLSAyMCVcbiAgICAgICAgaWYgKGxldmVsICE9PSAncmVzZXQnKSB7XG4gICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBpbnRlcnZhbCAqIDAuMjtcbiAgICAgICAgICAgIGludGVydmFsID0gTWF0aC5yb3VuZChpbnRlcnZhbCArIChNYXRoLnJhbmRvbSgpICogaml0dGVyICogMiAtIGppdHRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHVlRGF0ZSA9IG5ldyBEYXRlKG5vdyk7XG4gICAgICAgIGR1ZURhdGUuc2V0RGF0ZShkdWVEYXRlLmdldERhdGUoKSArIGludGVydmFsKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIHNjaGVkdWxlcjoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUuc2NoZWR1bGVyLFxuICAgICAgICAgICAgICAgIGludGVydmFsLFxuICAgICAgICAgICAgICAgIGVhc2VGYWN0b3I6IGVmYWN0b3IsIC8vIENvcnJlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gJ2VmYWN0b3InIHRvICdlYXNlRmFjdG9yJ1xuICAgICAgICAgICAgICAgIGR1ZURhdGU6IGR1ZURhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHNhdmVNZW1vcnlOb2Rlcyh1cGRhdGVkTm9kZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRBbGxNYXR1cml0eSgpOiB2b2lkIHtcbiAgICAvLyAxLiBDbGVhciBhbGwgbWVtb3J5IG5vZGVzXG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTUVNT1JZX05PREVTLCBbXSk7XG4gICAgXG4gICAgLy8gMi4gQ2xlYXIgYWxsIHJldmlldyBlcnJvcnNcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5SRVZJRVdfRVJST1JTLCBbXSk7XG5cbiAgICAvLyAzLiBSZWdlbmVyYXRlIG5vZGVzIGJhc2VkIG9uIGN1cnJlbnRseSBsZWFybmVkIHN1cmFocyBhbmQgY29tcGxldGVkIG1pbmRtYXBzXG4gICAgc3luY01lbW9yeU5vZGVzV2l0aExlYXJuZWQodHJ1ZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5jaG9ySXNzdWUge1xuICAgIGFuY2hvcklkOiBzdHJpbmc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBzdXJhaElkOiBudW1iZXI7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICBzdGFydFZlcnNlPzogbnVtYmVyO1xuICAgIGVuZFZlcnNlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQW5jaG9ycyh0aHJlc2hvbGQ6IG51bWJlciA9IDMpOiBBbmNob3JJc3N1ZVtdIHtcbiAgICByZXR1cm4gZ2V0RXJyb3JzQnlBbmNob3IoKVxuICAgICAgICAuZmlsdGVyKGUgPT4gZS5jb3VudCA+PSB0aHJlc2hvbGQgJiYgZS5zdXJhaElkICYmIGUuYW5jaG9ySWQpXG4gICAgICAgIC5tYXAoZSA9PiAoe1xuICAgICAgICAgICAgYW5jaG9ySWQ6IGUuYW5jaG9ySWQhLFxuICAgICAgICAgICAgbGFiZWw6IGUubGFiZWwsXG4gICAgICAgICAgICBzdXJhaElkOiBlLnN1cmFoSWQhLFxuICAgICAgICAgICAgY291bnQ6IGUuY291bnQsXG4gICAgICAgICAgICBzdGFydFZlcnNlOiBlLnN0YXJ0VmVyc2UsXG4gICAgICAgICAgICBlbmRWZXJzZTogZS5lbmRWZXJzZSxcbiAgICAgICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbmNob3JJc3N1ZXMoc3VyYWhJZDogbnVtYmVyLCBhbmNob3JJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZ2V0UmV2aWV3RXJyb3JzKCkuZmlsdGVyKGVyciA9PiAhKGVyci5zdXJhaElkID09PSBzdXJhaElkICYmIGVyci5hbmNob3JJZCA9PT0gYW5jaG9ySWQpKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuUkVWSUVXX0VSUk9SUywgSlNPTi5zdHJpbmdpZnkocmVtYWluaW5nKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQW5jaG9yRm9yUmFuZ2Uoc3VyYWhJZDogbnVtYmVyLCBzdGFydFZlcnNlPzogbnVtYmVyLCBlbmRWZXJzZT86IG51bWJlcik6IEFuY2hvciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgbWluZG1hcCA9IGdldE1pbmRNYXAoc3VyYWhJZCk7XG4gICAgaWYgKCFzdGFydFZlcnNlIHx8ICFlbmRWZXJzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWluZG1hcC5hbmNob3JzLmZpbmQoYSA9PiBhLnN0YXJ0VmVyc2UgPD0gc3RhcnRWZXJzZSAmJiBhLmVuZFZlcnNlID49IGVuZFZlcnNlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNdXRhc2hhYmloYXREZWNpc2lvbiB7XG4gICAgc3RhdHVzOiAncGVuZGluZycgfCAnaWdub3JlZCcgfCAnc29sdmVkX21pbmRtYXAnIHwgJ3NvbHZlZF9ub3RlJztcbiAgICBub3RlPzogc3RyaW5nO1xuICAgIGNvbmZpcm1lZEF0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbU11dGFzaGFiaWgge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdmVyc2UxOiB7IHN1cmFoSWQ6IG51bWJlcjsgYXlhaElkOiBudW1iZXIgfTtcbiAgICB2ZXJzZTI6IHsgc3VyYWhJZDogbnVtYmVyOyBheWFoSWQ6IG51bWJlciB9O1xuICAgIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2lnbm9yZWQnIHwgJ3NvbHZlZF9taW5kbWFwJyB8ICdzb2x2ZWRfbm90ZSc7XG4gICAgbm90ZT86IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgICBpc0N1c3RvbTogdHJ1ZTsgLy8gRGlzdGluY3Rpb24gZm9yIGRldmVsb3BtZW50IHB1cnBvc2VzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXN0b21NdXRhc2hhYmloYXQoKTogQ3VzdG9tTXV0YXNoYWJpaFtdIHtcbiAgICByZXR1cm4gZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5DVVNUT01fTVVUQVNIQUJJSEFULCBbXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQ3VzdG9tTXV0YXNoYWJpaChtdXQ6IEN1c3RvbU11dGFzaGFiaWgpOiB2b2lkIHtcbiAgICBjb25zdCBhbGwgPSBnZXRDdXN0b21NdXRhc2hhYmloYXQoKTtcbiAgICBjb25zdCBleGlzdGluZ0lkeCA9IGFsbC5maW5kSW5kZXgobSA9PiBtLmlkID09PSBtdXQuaWQpO1xuICAgIGlmIChleGlzdGluZ0lkeCA+PSAwKSB7XG4gICAgICAgIGFsbFtleGlzdGluZ0lkeF0gPSBtdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxsLnB1c2gobXV0KTtcbiAgICB9XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuQ1VTVE9NX01VVEFTSEFCSUhBVCwgYWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUN1c3RvbU11dGFzaGFiaWgoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGFsbCA9IGdldEN1c3RvbU11dGFzaGFiaWhhdCgpLmZpbHRlcihtID0+IG0uaWQgIT09IGlkKTtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5DVVNUT01fTVVUQVNIQUJJSEFULCBhbGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TXV0YXNoYWJpaGF0RGVjaXNpb25zKCk6IFJlY29yZDxzdHJpbmcsIE11dGFzaGFiaWhhdERlY2lzaW9uPiB7XG4gICAgcmV0dXJuIGdldEZyb21DYWNoZShTVE9SQUdFX0tFWVMuTVVUQVNIQUJJSEFUX0RFQ0lTSU9OUywge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TXV0YXNoYWJpaGF0RGVjaXNpb24oYWJzb2x1dGVBeWFoOiBudW1iZXIsIGRlY2lzaW9uOiBNdXRhc2hhYmloYXREZWNpc2lvbiwgcGhyYXNlSWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkZWNpc2lvbnMgPSBnZXRNdXRhc2hhYmloYXREZWNpc2lvbnMoKTtcbiAgICBjb25zdCBrZXkgPSBwaHJhc2VJZCA/IGAke2Fic29sdXRlQXlhaH0tJHtwaHJhc2VJZH1gIDogYWJzb2x1dGVBeWFoLnRvU3RyaW5nKCk7XG4gICAgZGVjaXNpb25zW2tleV0gPSBkZWNpc2lvbjtcbiAgICBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5NVVRBU0hBQklIQVRfREVDSVNJT05TLCBkZWNpc2lvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRNdXRhc2hhYmloYXREZWNpc2lvbnMoYWJzb2x1dGVBeWF0OiBudW1iZXJbXSk6IHZvaWQge1xuICAgIGNvbnN0IGRlY2lzaW9ucyA9IGdldE11dGFzaGFiaWhhdERlY2lzaW9ucygpO1xuICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IE9iamVjdC5rZXlzKGRlY2lzaW9ucykuZmlsdGVyKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGFicyA9IHBhcnNlSW50KGtleS5zcGxpdCgnLScpWzBdLCAxMCk7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZUF5YXQuaW5jbHVkZXMoYWJzKTtcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoa2V5c1RvRGVsZXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIFxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiBkZWxldGUgZGVjaXNpb25zW2tleV0pO1xuICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1VVEFTSEFCSUhBVF9ERUNJU0lPTlMsIGRlY2lzaW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWxrU2V0U3VyYWhTdGF0dXMoc3VyYWhJZHM6IG51bWJlcltdLCBzdGF0dXM6ICdsZWFybmVkJyB8ICduZXcnIHwgJ3NraXBwZWQnKTogdm9pZCB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IGFsbFN1cmFocyA9IFNVUkFIUztcblxuICAgIHN1cmFoSWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzdXJhaCA9IGFsbFN1cmFocy5maW5kKHMgPT4gcy5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoIXN1cmFoKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3VyYWhLZXkgPSBpZC50b1N0cmluZygpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgc3RhdGUgZm9yIHRoaXMgc3VyYWggZmlyc3RcbiAgICAgICAgZGVsZXRlIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldO1xuICAgICAgICBzZXR0aW5ncy5za2lwcGVkU3VyYWhzID0gKHNldHRpbmdzLnNraXBwZWRTdXJhaHMgfHwgW10pLmZpbHRlcihzSWQgPT4gc0lkICE9PSBpZCk7XG5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2xlYXJuZWQnKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzZUlkcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHN1cmFoLnZlcnNlQ291bnQgfSwgKF8sIGkpID0+IGkgKyAxKTtcbiAgICAgICAgICAgIHNldHRpbmdzLmxlYXJuZWRWZXJzZXNbc3VyYWhLZXldID0gdmVyc2VJZHM7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnc2tpcHBlZCcpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNraXBwZWRTdXJhaHMgPSBbLi4uKHNldHRpbmdzLnNraXBwZWRTdXJhaHMgfHwgW10pLCBpZF07XG4gICAgICAgICAgICBwcnVuZVN1cmFoQXJ0aWZhY3RzKGlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAnbmV3JyBzdGF0dXMgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSByZXNldHMgYWJvdmVcbiAgICB9KTtcblxuICAgIGlmIChzZXR0aW5ncy5za2lwcGVkU3VyYWhzKSB7XG4gICAgICAgIHNldHRpbmdzLnNraXBwZWRTdXJhaHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cbiAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MpO1xufVxuXG5mdW5jdGlvbiBwcnVuZVN1cmFoQXJ0aWZhY3RzKHN1cmFoSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFJlbW92ZSBtZW1vcnkgbm9kZXMgZm9yIHRoaXMgc3VyYWhcbiAgICBjb25zdCBub2RlcyA9IGdldE1lbW9yeU5vZGVzKCkuZmlsdGVyKG4gPT4gbi5zdXJhaElkICE9PSBzdXJhaElkKTtcbiAgICBzYXZlTWVtb3J5Tm9kZXMobm9kZXMpO1xuXG4gICAgLy8gUmVtb3ZlIHN1cmFoIG1pbmRtYXBcbiAgICBjb25zdCBtYXBzID0gZ2V0TWluZE1hcHMoKTtcbiAgICBpZiAobWFwc1tzdXJhaElkXSkge1xuICAgICAgICBkZWxldGUgbWFwc1tzdXJhaElkXTtcbiAgICAgICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTUlORE1BUFMsIG1hcHMpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSByZXZpZXcgZXJyb3JzXG4gICAgY29uc3QgcmVtYWluaW5nRXJyb3JzID0gZ2V0UmV2aWV3RXJyb3JzKCkuZmlsdGVyKGVyciA9PiBlcnIuc3VyYWhJZCAhPT0gc3VyYWhJZCk7XG4gICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuUkVWSUVXX0VSUk9SUywgcmVtYWluaW5nRXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlU3VzcGVuZGVkKG5vZGU6IE1lbW9yeU5vZGUsIGlzc3VlczogQW5jaG9ySXNzdWVbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghbm9kZS5zdXJhaElkKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcmVsYXRlZElzc3VlcyA9IGlzc3Vlcy5maWx0ZXIoaSA9PiBpLnN1cmFoSWQgPT09IG5vZGUuc3VyYWhJZCk7XG4gICAgaWYgKHJlbGF0ZWRJc3N1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnbWluZG1hcCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd2ZXJzZScpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gZmluZEFuY2hvckZvclJhbmdlKG5vZGUuc3VyYWhJZCwgbm9kZS5zdGFydFZlcnNlLCBub2RlLmVuZFZlcnNlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IHJlbGF0ZWRJc3N1ZXMuc29tZShpID0+IGkuYW5jaG9ySWQgPT09IGFuY2hvci5pZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2t1cERhdGEge1xuICAgIHNldHRpbmdzPzogQXBwU2V0dGluZ3M7XG4gICAgbWVtb3J5Tm9kZXM/OiBNZW1vcnlOb2RlW107XG4gICAgbWluZG1hcHM/OiB7IFtzdXJhaElkOiBzdHJpbmddOiBNaW5kTWFwIH07XG4gICAgcGFydE1pbmRtYXBzPzogeyBbcGFydElkOiBzdHJpbmddOiBQYXJ0TWluZE1hcCB9O1xuICAgIGxpc3RlbmluZ1N0YXRzPzogeyBbc3VyYWhJZDogc3RyaW5nXTogTGlzdGVuaW5nU3RhdHMgfTtcbiAgICBsaXN0ZW5pbmdQcm9ncmVzcz86IFJlY29yZDxzdHJpbmcsIExpc3RlbmluZ1Byb2dyZXNzPjtcbiAgICByZXZpZXdFcnJvcnM/OiBSZXZpZXdFcnJvcltdO1xuICAgIG11dGFzaGFiaWhhdERlY2lzaW9ucz86IFJlY29yZDxzdHJpbmcsIE11dGFzaGFiaWhhdERlY2lzaW9uPjtcbiAgICBjdXN0b21NdXRhc2hhYmloYXQ/OiBDdXN0b21NdXRhc2hhYmloW107XG4gICAgY3ljbGVTdGFydD86IHN0cmluZztcbiAgICBsaXN0ZW5pbmdDb21wbGV0ZT86IHN0cmluZyB8IG51bGw7XG4gICAgZXhwb3J0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0QmFja3VwKCk6IEJhY2t1cERhdGEge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNldHRpbmdzOiBnZXRTZXR0aW5ncygpLFxuICAgICAgICBtZW1vcnlOb2RlczogZ2V0TWVtb3J5Tm9kZXMoKSxcbiAgICAgICAgbWluZG1hcHM6IGdldE1pbmRNYXBzKCksXG4gICAgICAgIHBhcnRNaW5kbWFwczogZ2V0UGFydE1pbmRNYXBzKCksXG4gICAgICAgIGxpc3RlbmluZ1N0YXRzOiBnZXRMaXN0ZW5pbmdTdGF0cygpLFxuICAgICAgICBsaXN0ZW5pbmdQcm9ncmVzczogZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfUFJPR1JFU1MsIHt9KSxcbiAgICAgICAgcmV2aWV3RXJyb3JzOiBnZXRSZXZpZXdFcnJvcnMoKSxcbiAgICAgICAgbXV0YXNoYWJpaGF0RGVjaXNpb25zOiBnZXRNdXRhc2hhYmloYXREZWNpc2lvbnMoKSxcbiAgICAgICAgY3VzdG9tTXV0YXNoYWJpaGF0OiBnZXRDdXN0b21NdXRhc2hhYmloYXQoKSxcbiAgICAgICAgY3ljbGVTdGFydDogZ2V0Q3ljbGVTdGFydCgpLFxuICAgICAgICBsaXN0ZW5pbmdDb21wbGV0ZTogZ2V0RnJvbUNhY2hlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfQ09NUExFVEUsIG51bGwpLFxuICAgICAgICBleHBvcnRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydEJhY2t1cChkYXRhOiBCYWNrdXBEYXRhKTogdm9pZCB7XG4gICAgaWYgKGRhdGEuc2V0dGluZ3MpIHNhdmVTZXR0aW5ncyhkYXRhLnNldHRpbmdzKTtcbiAgICBpZiAoZGF0YS5tZW1vcnlOb2Rlcykgc2F2ZU1lbW9yeU5vZGVzKGRhdGEubWVtb3J5Tm9kZXMpO1xuICAgIGlmIChkYXRhLm1pbmRtYXBzKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1JTkRNQVBTLCBkYXRhLm1pbmRtYXBzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucGFydE1pbmRtYXBzKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLlBBUlRfTUlORE1BUFMsIGRhdGEucGFydE1pbmRtYXBzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGlzdGVuaW5nU3RhdHMpIHtcbiAgICAgICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTElTVEVOSU5HX1NUQVRTLCBkYXRhLmxpc3RlbmluZ1N0YXRzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGlzdGVuaW5nUHJvZ3Jlc3MpIHtcbiAgICAgICAgc2F2ZVRvQ2FjaGVBbmRTdG9yZShTVE9SQUdFX0tFWVMuTElTVEVOSU5HX1BST0dSRVNTLCBkYXRhLmxpc3RlbmluZ1Byb2dyZXNzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEucmV2aWV3RXJyb3JzKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLlJFVklFV19FUlJPUlMsIGRhdGEucmV2aWV3RXJyb3JzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubXV0YXNoYWJpaGF0RGVjaXNpb25zKSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLk1VVEFTSEFCSUhBVF9ERUNJU0lPTlMsIGRhdGEubXV0YXNoYWJpaGF0RGVjaXNpb25zKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3VzdG9tTXV0YXNoYWJpaGF0KSB7XG4gICAgICAgIHNhdmVUb0NhY2hlQW5kU3RvcmUoU1RPUkFHRV9LRVlTLkNVU1RPTV9NVVRBU0hBQklIQVQsIGRhdGEuY3VzdG9tTXV0YXNoYWJpaGF0KTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3ljbGVTdGFydCkgc2V0Q3ljbGVTdGFydChkYXRhLmN5Y2xlU3RhcnQpO1xuICAgIGlmIChkYXRhLmxpc3RlbmluZ0NvbXBsZXRlKSBzYXZlVG9DYWNoZUFuZFN0b3JlKFNUT1JBR0VfS0VZUy5MSVNURU5JTkdfQ09NUExFVEUsIGRhdGEubGlzdGVuaW5nQ29tcGxldGUpO1xufVxuIl0sIm5hbWVzIjpbIlNVUkFIUyIsImdldCIsInNldCIsImNyZWF0ZVN0b3JlIiwiY3VzdG9tU3RvcmUiLCJ1bmRlZmluZWQiLCJtaWdyYXRlRnJvbUxvY2FsU3RvcmFnZSIsIm1pZ3JhdGlvbkZsYWciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwia2V5IiwiT2JqZWN0IiwidmFsdWVzIiwiU1RPUkFHRV9LRVlTIiwidmFsdWUiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwic2V0SXRlbSIsImxvZyIsInN0b3JhZ2VDYWNoZSIsImxvYWRJbnRvQ2FjaGUiLCJnZXRGcm9tQ2FjaGUiLCJkZWZhdWx0VmFsdWUiLCJjYWNoZWQiLCJzYXZlVG9DYWNoZUFuZFN0b3JlIiwiY2F0Y2giLCJlcnIiLCJTRVRUSU5HUyIsIk1FTU9SWV9OT0RFUyIsIk1JTkRNQVBTIiwiUEFSVF9NSU5ETUFQUyIsIkxJU1RFTklOR19QUk9HUkVTUyIsIkxJU1RFTklOR19TVEFUUyIsIkNZQ0xFX1NUQVJUIiwiTElTVEVOSU5HX0NPTVBMRVRFIiwiUkVWSUVXX0VSUk9SUyIsIk1VVEFTSEFCSUhBVF9ERUNJU0lPTlMiLCJDVVNUT01fTVVUQVNIQUJJSEFUIiwiREVGQVVMVF9TRVRUSU5HUyIsImNvbXBsZXRpb25EYXlzIiwiYWN0aXZlUGFydCIsImxlYXJuZWRWZXJzZXMiLCJza2lwcGVkU3VyYWhzIiwiZ2V0U2V0dGluZ3MiLCJzYXZlU2V0dGluZ3MiLCJzZXR0aW5ncyIsInVwZGF0ZVNldHRpbmciLCJpc1N1cmFoU2tpcHBlZCIsInN1cmFoSWQiLCJpbmNsdWRlcyIsInRvZ2dsZVN1cmFoU2tpcHBlZCIsImN1cnJlbnQiLCJTZXQiLCJoYXMiLCJkZWxldGUiLCJhZGQiLCJwcnVuZVN1cmFoQXJ0aWZhY3RzIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwiaXNWZXJzZUxlYXJuZWQiLCJheWFoSWQiLCJ0b2dnbGVWZXJzZUxlYXJuZWQiLCJzdXJhaEtleSIsInRvU3RyaW5nIiwiZmlsdGVyIiwidiIsImxlbmd0aCIsInN5bmNNZW1vcnlOb2Rlc1dpdGhMZWFybmVkIiwidG9nZ2xlU3VyYWhMZWFybmVkIiwic3VyYWgiLCJmaW5kIiwicyIsImlkIiwidmVyc2VDb3VudCIsIl8iLCJpIiwiZ2V0U3VyYWhMZWFybmVkU3RhdHVzIiwibGVhcm5lZCIsInRvdGFsIiwiZ2V0VG90YWxMZWFybmVkVmVyc2VzIiwicmVkdWNlIiwic3VtIiwidmVyc2VzIiwiZ2V0TGVhcm5lZFZlcnNlc0luUGFydCIsInBhcnQiLCJyZXN1bHQiLCJmb3JFYWNoIiwicHVzaCIsImdldE1lbW9yeU5vZGVzIiwic2F2ZU1lbW9yeU5vZGVzIiwibm9kZXMiLCJnZXREdWVOb2RlcyIsInRvZGF5IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJza2lwcyIsInN1c3BlbmRlZCIsImdldFN1c3BlbmRlZEFuY2hvcnMiLCJuIiwic2NoZWR1bGVyIiwiZHVlRGF0ZSIsImlzTm9kZVN1c3BlbmRlZCIsInVwZGF0ZU1lbW9yeU5vZGUiLCJub2RlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJjcmVhdGVOZXdTY2hlZHVsZXIiLCJpbnRlcnZhbCIsInJlcGV0aXRpb24iLCJlYXNlRmFjdG9yIiwibGFzdFJldmlldyIsImZvcmNlRnVsbFJlc2V0IiwiZW50cmllcyIsInN1cmFoSWRTdHIiLCJwYXJzZUludCIsInNvcnRlZFZlcnNlcyIsInNlZ21lbnRTdGFydCIsInNlZ21lbnRFbmQiLCJpc0NvbnRpZ3VvdXMiLCJzZWdtZW50U2l6ZSIsIm5vZGVJZCIsImV4aXN0cyIsInNvbWUiLCJuZXdOb2RlIiwidHlwZSIsInN0YXJ0VmVyc2UiLCJlbmRWZXJzZSIsIm1pbmRtYXBzIiwiZ2V0TWluZE1hcHMiLCJtbSIsImlzQ29tcGxldGUiLCJwYXJ0TWluZG1hcHMiLCJnZXRQYXJ0TWluZE1hcHMiLCJwbW0iLCJwYXJ0SWQiLCJzbTIiLCJncmFkZSIsInN0YXRlIiwiTWF0aCIsInJvdW5kIiwibWF4Iiwic2V0RGF0ZSIsImdldERhdGUiLCJwb3N0cG9uZU5vZGUiLCJ0b21vcnJvdyIsImdldE1pbmRNYXAiLCJtYXBzIiwiaW1hZ2VVcmwiLCJhbmNob3JzIiwic2F2ZU1pbmRNYXAiLCJtaW5kbWFwIiwiZ2V0UGFydE1pbmRNYXAiLCJkZXNjcmlwdGlvbiIsInNhdmVQYXJ0TWluZE1hcCIsImdldExpc3RlbmluZ1Byb2dyZXNzIiwibWFwIiwiY3VycmVudFZlcnNlSW5kZXgiLCJzYXZlTGlzdGVuaW5nUHJvZ3Jlc3MiLCJnZXRMaXN0ZW5pbmdTdGF0cyIsImdldExpc3RlbmluZ1N0YXRzRm9yU3VyYWgiLCJzdGF0cyIsInRvdGFsTWludXRlcyIsImxhc3RMaXN0ZW5lZCIsImFkZExpc3RlbmluZ1RpbWUiLCJtaW51dGVzIiwiZ2V0TGlzdGVuaW5nQ29tcGxldGVkVG9kYXkiLCJzdG9yZWQiLCJtYXJrTGlzdGVuaW5nQ29tcGxldGUiLCJnZXRSZXZpZXdFcnJvcnMiLCJzYXZlUmV2aWV3RXJyb3IiLCJlcnJvcnMiLCJ0cmltbWVkIiwic2xpY2UiLCJyZW1vdmVSZXZpZXdFcnJvciIsInJlbWFpbmluZyIsImdldEVycm9yc0J5QW5jaG9yIiwiYW5jaG9yQ291bnRzIiwiYW5jaG9yIiwibGFiZWwiLCJjb3VudCIsImFuY2hvcklkIiwiZ2V0Q3ljbGVTdGFydCIsInNldEN5Y2xlU3RhcnQiLCJkYXRlIiwiZ2V0Q3VycmVudERheUluQ3ljbGUiLCJzdGFydCIsImRpZmYiLCJmbG9vciIsImdldFRpbWUiLCJzZXRTdXJhaE1hdHVyaXR5IiwibGV2ZWwiLCJub3ciLCJ1cGRhdGVkTm9kZXMiLCJlZmFjdG9yIiwiaml0dGVyIiwicmFuZG9tIiwicmVzZXRBbGxNYXR1cml0eSIsInRocmVzaG9sZCIsImNsZWFyQW5jaG9ySXNzdWVzIiwic3RyaW5naWZ5IiwiZmluZEFuY2hvckZvclJhbmdlIiwiZ2V0Q3VzdG9tTXV0YXNoYWJpaGF0Iiwic2F2ZUN1c3RvbU11dGFzaGFiaWgiLCJtdXQiLCJhbGwiLCJleGlzdGluZ0lkeCIsIm0iLCJkZWxldGVDdXN0b21NdXRhc2hhYmloIiwiZ2V0TXV0YXNoYWJpaGF0RGVjaXNpb25zIiwic2V0TXV0YXNoYWJpaGF0RGVjaXNpb24iLCJhYnNvbHV0ZUF5YWgiLCJkZWNpc2lvbiIsInBocmFzZUlkIiwiZGVjaXNpb25zIiwicmVzZXRNdXRhc2hhYmloYXREZWNpc2lvbnMiLCJhYnNvbHV0ZUF5YXQiLCJrZXlzVG9EZWxldGUiLCJrZXlzIiwiYWJzIiwiYnVsa1NldFN1cmFoU3RhdHVzIiwic3VyYWhJZHMiLCJzdGF0dXMiLCJhbGxTdXJhaHMiLCJzSWQiLCJ2ZXJzZUlkcyIsInJlbWFpbmluZ0Vycm9ycyIsImlzc3VlcyIsInJlbGF0ZWRJc3N1ZXMiLCJleHBvcnRCYWNrdXAiLCJtZW1vcnlOb2RlcyIsImxpc3RlbmluZ1N0YXRzIiwibGlzdGVuaW5nUHJvZ3Jlc3MiLCJyZXZpZXdFcnJvcnMiLCJtdXRhc2hhYmloYXREZWNpc2lvbnMiLCJjdXN0b21NdXRhc2hhYmloYXQiLCJjeWNsZVN0YXJ0IiwibGlzdGVuaW5nQ29tcGxldGUiLCJleHBvcnRlZEF0IiwiaW1wb3J0QmFja3VwIiwiZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/storage.ts\n"));

/***/ })

});