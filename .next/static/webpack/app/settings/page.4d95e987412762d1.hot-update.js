"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/settings/page",{

/***/ "(app-pages-browser)/./src/lib/sync.ts":
/*!*************************!*\
  !*** ./src/lib/sync.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   syncWithCloud: function() { return /* binding */ syncWithCloud; }\n/* harmony export */ });\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _googleDrive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./googleDrive */ \"(app-pages-browser)/./src/lib/googleDrive.ts\");\n\n\n/**\n * Orchestrates the sync process:\n * 1. Pull remote data from Google Drive\n * 2. Merge with local data\n * 3. Push merged data back to Google Drive (if changed)\n */ async function syncWithCloud(accessToken) {\n    try {\n        const localData = (0,_storage__WEBPACK_IMPORTED_MODULE_0__.exportBackup)();\n        const { data: remoteData, fileId } = await (0,_googleDrive__WEBPACK_IMPORTED_MODULE_1__.fetchBackupFile)(accessToken);\n        if (!remoteData) {\n            // No remote data, push local data as the first backup\n            await (0,_googleDrive__WEBPACK_IMPORTED_MODULE_1__.uploadBackupFile)(accessToken, localData, null);\n            return {\n                status: \"success\",\n                message: \"Initial backup created on Google Drive\"\n            };\n        }\n        // Merge logic\n        const { mergedData, hasChanges } = mergeBackups(localData, remoteData);\n        if (hasChanges) {\n            // Update local storage\n            mergedData.settings = {\n                ...mergedData.settings || {},\n                lastSyncedAt: new Date().toISOString()\n            };\n            (0,_storage__WEBPACK_IMPORTED_MODULE_0__.importBackup)(mergedData);\n            // Update remote storage\n            await (0,_googleDrive__WEBPACK_IMPORTED_MODULE_1__.uploadBackupFile)(accessToken, mergedData, fileId);\n            return {\n                status: \"success\",\n                message: \"Sync complete: data merged\"\n            };\n        }\n        // Even if no data changed, update the sync timestamp locally\n        const settings = {\n            ...localData.settings || {}\n        };\n        settings.lastSyncedAt = new Date().toISOString();\n        (0,_storage__WEBPACK_IMPORTED_MODULE_0__.importBackup)({\n            ...localData,\n            settings\n        });\n        return {\n            status: \"no_change\",\n            message: \"Already in sync\"\n        };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return {\n            status: \"error\",\n            message: error.message || \"Unknown sync error\"\n        };\n    }\n}\n/**\n * Merges local and remote backups.\n * Simple strategy: \n * - For sets/dictionaries: Union of keys/values\n * - For single values: Latest date wins\n */ function mergeBackups(local, remote) {\n    const merged = {\n        ...local\n    };\n    let hasChanges = false;\n    // 1. Settings (Learned Verses & Skipped Surahs)\n    if (remote.settings) {\n        var _local_settings, _remote_settings, _local_settings1, _remote_settings1;\n        // Merge learnedVerses (Union)\n        const localLearned = ((_local_settings = local.settings) === null || _local_settings === void 0 ? void 0 : _local_settings.learnedVerses) || {};\n        const remoteLearned = ((_remote_settings = remote.settings) === null || _remote_settings === void 0 ? void 0 : _remote_settings.learnedVerses) || {};\n        const allSurahIds = Array.from(new Set([\n            ...Object.keys(localLearned),\n            ...Object.keys(remoteLearned)\n        ]));\n        const mergedLearned = {};\n        for (const id of allSurahIds){\n            const combined = new Set([\n                ...localLearned[id] || [],\n                ...remoteLearned[id] || []\n            ]);\n            mergedLearned[id] = Array.from(combined).sort((a, b)=>a - b);\n            if (JSON.stringify(mergedLearned[id]) !== JSON.stringify(localLearned[id])) {\n                hasChanges = true;\n            }\n        }\n        // Merge skippedSurahs (Union)\n        const localSkipped = new Set(((_local_settings1 = local.settings) === null || _local_settings1 === void 0 ? void 0 : _local_settings1.skippedSurahs) || []);\n        const remoteSkipped = ((_remote_settings1 = remote.settings) === null || _remote_settings1 === void 0 ? void 0 : _remote_settings1.skippedSurahs) || [];\n        remoteSkipped.forEach((id)=>{\n            if (!localSkipped.has(id)) {\n                localSkipped.add(id);\n                hasChanges = true;\n            }\n        });\n        merged.settings = {\n            ...local.settings,\n            learnedVerses: mergedLearned,\n            skippedSurahs: Array.from(localSkipped).sort((a, b)=>a - b)\n        };\n    }\n    // 2. Memory Nodes (Latest SM-2 state wins per node ID)\n    if (remote.memoryNodes) {\n        const localNodes = local.memoryNodes || [];\n        const remoteNodes = remote.memoryNodes || [];\n        const nodeMap = new Map(localNodes.map((n)=>[\n                n.id,\n                n\n            ]));\n        remoteNodes.forEach((rNode)=>{\n            const lNode = nodeMap.get(rNode.id);\n            if (!lNode || rNode.scheduler.lastReview > lNode.scheduler.lastReview) {\n                nodeMap.set(rNode.id, rNode);\n                hasChanges = true;\n            }\n        });\n        merged.memoryNodes = Array.from(nodeMap.values());\n    }\n    // 3. Mutashabihat Decisions (Latest confirmedAt wins)\n    if (remote.mutashabihatDecisions) {\n        const localDecs = local.mutashabihatDecisions || {};\n        const remoteDecs = remote.mutashabihatDecisions || {};\n        const allKeys = Array.from(new Set([\n            ...Object.keys(localDecs),\n            ...Object.keys(remoteDecs)\n        ]));\n        const mergedDecs = {};\n        for (const key of allKeys){\n            const l = localDecs[key];\n            const r = remoteDecs[key];\n            if (!l) {\n                mergedDecs[key] = r;\n                hasChanges = true;\n            } else if (!r) {\n                mergedDecs[key] = l;\n            } else {\n                const lTime = l.confirmedAt || \"\";\n                const rTime = r.confirmedAt || \"\";\n                if (rTime > lTime) {\n                    mergedDecs[key] = r;\n                    hasChanges = true;\n                } else {\n                    mergedDecs[key] = l;\n                }\n            }\n        }\n        merged.mutashabihatDecisions = mergedDecs;\n    }\n    // 4. Custom Mutashabihat (Union by ID)\n    if (remote.customMutashabihat) {\n        const localCustoms = local.customMutashabihat || [];\n        const remoteCustoms = remote.customMutashabihat || [];\n        const customMap = new Map(localCustoms.map((c)=>[\n                c.id,\n                c\n            ]));\n        remoteCustoms.forEach((rc)=>{\n            if (!customMap.has(rc.id)) {\n                customMap.set(rc.id, rc);\n                hasChanges = true;\n            }\n        });\n        merged.customMutashabihat = Array.from(customMap.values());\n    }\n    // Simple \"Latest wins\" for the rest\n    const remoteTime = remote.exportedAt || \"\";\n    const localTime = local.exportedAt || \"\";\n    if (remoteTime > localTime) {\n        if (JSON.stringify(remote.mindmaps) !== JSON.stringify(local.mindmaps)) {\n            merged.mindmaps = remote.mindmaps;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.partMindmaps) !== JSON.stringify(local.partMindmaps)) {\n            merged.partMindmaps = remote.partMindmaps;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.listeningStats) !== JSON.stringify(local.listeningStats)) {\n            merged.listeningStats = remote.listeningStats;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.listeningProgress) !== JSON.stringify(local.listeningProgress)) {\n            merged.listeningProgress = remote.listeningProgress;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.reviewErrors) !== JSON.stringify(local.reviewErrors)) {\n            merged.reviewErrors = remote.reviewErrors;\n            hasChanges = true;\n        }\n        if (remote.cycleStart !== local.cycleStart) {\n            merged.cycleStart = remote.cycleStart;\n            hasChanges = true;\n        }\n        if (remote.listeningComplete !== local.listeningComplete) {\n            merged.listeningComplete = remote.listeningComplete;\n            hasChanges = true;\n        }\n    }\n    merged.exportedAt = new Date().toISOString();\n    // If we had changes from remote, or we are pushing our newer local data\n    return {\n        mergedData: merged,\n        hasChanges: hasChanges || localTime > remoteTime\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixHQUFHOUQsT0FBTzhELGlCQUFpQjtZQUNuRHZFLGFBQWE7UUFDakI7UUFDQSxJQUFJMEIsS0FBS0MsU0FBUyxDQUFDbEIsT0FBTytELFlBQVksTUFBTTlDLEtBQUtDLFNBQVMsQ0FBQ25CLE1BQU1nRSxZQUFZLEdBQUc7WUFDNUU5RCxPQUFPOEQsWUFBWSxHQUFHL0QsT0FBTytELFlBQVk7WUFDekN4RSxhQUFhO1FBQ2pCO1FBQ0EsSUFBSVMsT0FBT2dFLFVBQVUsS0FBS2pFLE1BQU1pRSxVQUFVLEVBQUU7WUFDeEMvRCxPQUFPK0QsVUFBVSxHQUFHaEUsT0FBT2dFLFVBQVU7WUFDckN6RSxhQUFhO1FBQ2pCO1FBQ0EsSUFBSVMsT0FBT2lFLGlCQUFpQixLQUFLbEUsTUFBTWtFLGlCQUFpQixFQUFFO1lBQ3REaEUsT0FBT2dFLGlCQUFpQixHQUFHakUsT0FBT2lFLGlCQUFpQjtZQUNuRDFFLGFBQWE7UUFDakI7SUFDRjtJQUVBVSxPQUFPd0QsVUFBVSxHQUFHLElBQUk5RCxPQUFPQyxXQUFXO0lBRTFDLHdFQUF3RTtJQUN4RSxPQUFPO1FBQUVOLFlBQVlXO1FBQVFWLFlBQVlBLGNBQWNtRSxZQUFZRjtJQUFXO0FBQ2hGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3luYy50cz83NTc2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQmFja3VwRGF0YSwgZXhwb3J0QmFja3VwLCBpbXBvcnRCYWNrdXAgfSBmcm9tICcuL3N0b3JhZ2UnO1xuaW1wb3J0IHsgZmV0Y2hCYWNrdXBGaWxlLCB1cGxvYWRCYWNrdXBGaWxlIH0gZnJvbSAnLi9nb29nbGVEcml2ZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3luY1Jlc3VsdCB7XG4gIHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ25vX2NoYW5nZScgfCAnZXJyb3InO1xuICBtZXNzYWdlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE9yY2hlc3RyYXRlcyB0aGUgc3luYyBwcm9jZXNzOlxuICogMS4gUHVsbCByZW1vdGUgZGF0YSBmcm9tIEdvb2dsZSBEcml2ZVxuICogMi4gTWVyZ2Ugd2l0aCBsb2NhbCBkYXRhXG4gKiAzLiBQdXNoIG1lcmdlZCBkYXRhIGJhY2sgdG8gR29vZ2xlIERyaXZlIChpZiBjaGFuZ2VkKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3luY1dpdGhDbG91ZChhY2Nlc3NUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxTeW5jUmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbG9jYWxEYXRhID0gZXhwb3J0QmFja3VwKCk7XG4gICAgY29uc3QgeyBkYXRhOiByZW1vdGVEYXRhLCBmaWxlSWQgfSA9IGF3YWl0IGZldGNoQmFja3VwRmlsZShhY2Nlc3NUb2tlbik7XG5cbiAgICBpZiAoIXJlbW90ZURhdGEpIHtcbiAgICAgIC8vIE5vIHJlbW90ZSBkYXRhLCBwdXNoIGxvY2FsIGRhdGEgYXMgdGhlIGZpcnN0IGJhY2t1cFxuICAgICAgYXdhaXQgdXBsb2FkQmFja3VwRmlsZShhY2Nlc3NUb2tlbiwgbG9jYWxEYXRhLCBudWxsKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnLCBtZXNzYWdlOiAnSW5pdGlhbCBiYWNrdXAgY3JlYXRlZCBvbiBHb29nbGUgRHJpdmUnIH07XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgbG9naWNcbiAgICBjb25zdCB7IG1lcmdlZERhdGEsIGhhc0NoYW5nZXMgfSA9IG1lcmdlQmFja3Vwcyhsb2NhbERhdGEsIHJlbW90ZURhdGEpO1xuXG4gICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdG9yYWdlXG4gICAgICBtZXJnZWREYXRhLnNldHRpbmdzID0ge1xuICAgICAgICAuLi4obWVyZ2VkRGF0YS5zZXR0aW5ncyB8fCB7fSksXG4gICAgICAgIGxhc3RTeW5jZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9IGFzIGFueTtcbiAgICAgIFxuICAgICAgaW1wb3J0QmFja3VwKG1lcmdlZERhdGEpO1xuICAgICAgLy8gVXBkYXRlIHJlbW90ZSBzdG9yYWdlXG4gICAgICBhd2FpdCB1cGxvYWRCYWNrdXBGaWxlKGFjY2Vzc1Rva2VuLCBtZXJnZWREYXRhLCBmaWxlSWQpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnc3VjY2VzcycsIG1lc3NhZ2U6ICdTeW5jIGNvbXBsZXRlOiBkYXRhIG1lcmdlZCcgfTtcbiAgICB9XG5cbiAgICAvLyBFdmVuIGlmIG5vIGRhdGEgY2hhbmdlZCwgdXBkYXRlIHRoZSBzeW5jIHRpbWVzdGFtcCBsb2NhbGx5XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7IC4uLihsb2NhbERhdGEuc2V0dGluZ3MgfHwge30pIH0gYXMgYW55O1xuICAgIHNldHRpbmdzLmxhc3RTeW5jZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBpbXBvcnRCYWNrdXAoeyAuLi5sb2NhbERhdGEsIHNldHRpbmdzIH0pO1xuXG4gICAgcmV0dXJuIHsgc3RhdHVzOiAnbm9fY2hhbmdlJywgbWVzc2FnZTogJ0FscmVhZHkgaW4gc3luYycgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1N5bmMgZmFpbGVkOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gc3luYyBlcnJvcicgfTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlcyBsb2NhbCBhbmQgcmVtb3RlIGJhY2t1cHMuXG4gKiBTaW1wbGUgc3RyYXRlZ3k6IFxuICogLSBGb3Igc2V0cy9kaWN0aW9uYXJpZXM6IFVuaW9uIG9mIGtleXMvdmFsdWVzXG4gKiAtIEZvciBzaW5nbGUgdmFsdWVzOiBMYXRlc3QgZGF0ZSB3aW5zXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQmFja3Vwcyhsb2NhbDogQmFja3VwRGF0YSwgcmVtb3RlOiBCYWNrdXBEYXRhKTogeyBtZXJnZWREYXRhOiBCYWNrdXBEYXRhOyBoYXNDaGFuZ2VzOiBib29sZWFuIH0ge1xuICBjb25zdCBtZXJnZWQ6IEJhY2t1cERhdGEgPSB7IC4uLmxvY2FsIH07XG4gIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgLy8gMS4gU2V0dGluZ3MgKExlYXJuZWQgVmVyc2VzICYgU2tpcHBlZCBTdXJhaHMpXG4gIGlmIChyZW1vdGUuc2V0dGluZ3MpIHtcbiAgICAvLyBNZXJnZSBsZWFybmVkVmVyc2VzIChVbmlvbilcbiAgICBjb25zdCBsb2NhbExlYXJuZWQgPSBsb2NhbC5zZXR0aW5ncz8ubGVhcm5lZFZlcnNlcyB8fCB7fTtcbiAgICBjb25zdCByZW1vdGVMZWFybmVkID0gcmVtb3RlLnNldHRpbmdzPy5sZWFybmVkVmVyc2VzIHx8IHt9O1xuICAgIGNvbnN0IGFsbFN1cmFoSWRzID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhsb2NhbExlYXJuZWQpLCAuLi5PYmplY3Qua2V5cyhyZW1vdGVMZWFybmVkKV0pKTtcbiAgICBcbiAgICBjb25zdCBtZXJnZWRMZWFybmVkOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXT4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGFsbFN1cmFoSWRzKSB7XG4gICAgICBjb25zdCBjb21iaW5lZCA9IG5ldyBTZXQoWy4uLihsb2NhbExlYXJuZWRbaWRdIHx8IFtdKSwgLi4uKHJlbW90ZUxlYXJuZWRbaWRdIHx8IFtdKV0pO1xuICAgICAgbWVyZ2VkTGVhcm5lZFtpZF0gPSBBcnJheS5mcm9tKGNvbWJpbmVkKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobWVyZ2VkTGVhcm5lZFtpZF0pICE9PSBKU09OLnN0cmluZ2lmeShsb2NhbExlYXJuZWRbaWRdKSkge1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTWVyZ2Ugc2tpcHBlZFN1cmFocyAoVW5pb24pXG4gICAgY29uc3QgbG9jYWxTa2lwcGVkID0gbmV3IFNldChsb2NhbC5zZXR0aW5ncz8uc2tpcHBlZFN1cmFocyB8fCBbXSk7XG4gICAgY29uc3QgcmVtb3RlU2tpcHBlZCA9IHJlbW90ZS5zZXR0aW5ncz8uc2tpcHBlZFN1cmFocyB8fCBbXTtcbiAgICByZW1vdGVTa2lwcGVkLmZvckVhY2goaWQgPT4ge1xuICAgICAgaWYgKCFsb2NhbFNraXBwZWQuaGFzKGlkKSkge1xuICAgICAgICBsb2NhbFNraXBwZWQuYWRkKGlkKTtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtZXJnZWQuc2V0dGluZ3MgPSB7XG4gICAgICAuLi5sb2NhbC5zZXR0aW5ncyEsXG4gICAgICBsZWFybmVkVmVyc2VzOiBtZXJnZWRMZWFybmVkLFxuICAgICAgc2tpcHBlZFN1cmFoczogQXJyYXkuZnJvbShsb2NhbFNraXBwZWQpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gMi4gTWVtb3J5IE5vZGVzIChMYXRlc3QgU00tMiBzdGF0ZSB3aW5zIHBlciBub2RlIElEKVxuICBpZiAocmVtb3RlLm1lbW9yeU5vZGVzKSB7XG4gICAgY29uc3QgbG9jYWxOb2RlcyA9IGxvY2FsLm1lbW9yeU5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHJlbW90ZU5vZGVzID0gcmVtb3RlLm1lbW9yeU5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKGxvY2FsTm9kZXMubWFwKG4gPT4gW24uaWQsIG5dKSk7XG5cbiAgICByZW1vdGVOb2Rlcy5mb3JFYWNoKHJOb2RlID0+IHtcbiAgICAgIGNvbnN0IGxOb2RlID0gbm9kZU1hcC5nZXQock5vZGUuaWQpO1xuICAgICAgaWYgKCFsTm9kZSB8fCByTm9kZS5zY2hlZHVsZXIubGFzdFJldmlldyA+IGxOb2RlLnNjaGVkdWxlci5sYXN0UmV2aWV3KSB7XG4gICAgICAgIG5vZGVNYXAuc2V0KHJOb2RlLmlkLCByTm9kZSk7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lcmdlZC5tZW1vcnlOb2RlcyA9IEFycmF5LmZyb20obm9kZU1hcC52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyAzLiBNdXRhc2hhYmloYXQgRGVjaXNpb25zIChMYXRlc3QgY29uZmlybWVkQXQgd2lucylcbiAgaWYgKHJlbW90ZS5tdXRhc2hhYmloYXREZWNpc2lvbnMpIHtcbiAgICBjb25zdCBsb2NhbERlY3MgPSBsb2NhbC5tdXRhc2hhYmloYXREZWNpc2lvbnMgfHwge307XG4gICAgY29uc3QgcmVtb3RlRGVjcyA9IHJlbW90ZS5tdXRhc2hhYmloYXREZWNpc2lvbnMgfHwge307XG4gICAgY29uc3QgYWxsS2V5cyA9IEFycmF5LmZyb20obmV3IFNldChbLi4uT2JqZWN0LmtleXMobG9jYWxEZWNzKSwgLi4uT2JqZWN0LmtleXMocmVtb3RlRGVjcyldKSk7XG5cbiAgICBjb25zdCBtZXJnZWREZWNzOiB0eXBlb2YgbG9jYWxEZWNzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgY29uc3QgbCA9IGxvY2FsRGVjc1trZXldO1xuICAgICAgY29uc3QgciA9IHJlbW90ZURlY3Nba2V5XTtcbiAgICAgIGlmICghbCkge1xuICAgICAgICBtZXJnZWREZWNzW2tleV0gPSByO1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXIpIHtcbiAgICAgICAgbWVyZ2VkRGVjc1trZXldID0gbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxUaW1lID0gbC5jb25maXJtZWRBdCB8fCAnJztcbiAgICAgICAgY29uc3QgclRpbWUgPSByLmNvbmZpcm1lZEF0IHx8ICcnO1xuICAgICAgICBpZiAoclRpbWUgPiBsVGltZSkge1xuICAgICAgICAgIG1lcmdlZERlY3Nba2V5XSA9IHI7XG4gICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2VkRGVjc1trZXldID0gbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtZXJnZWQubXV0YXNoYWJpaGF0RGVjaXNpb25zID0gbWVyZ2VkRGVjcztcbiAgfVxuXG4gIC8vIDQuIEN1c3RvbSBNdXRhc2hhYmloYXQgKFVuaW9uIGJ5IElEKVxuICBpZiAocmVtb3RlLmN1c3RvbU11dGFzaGFiaWhhdCkge1xuICAgIGNvbnN0IGxvY2FsQ3VzdG9tcyA9IGxvY2FsLmN1c3RvbU11dGFzaGFiaWhhdCB8fCBbXTtcbiAgICBjb25zdCByZW1vdGVDdXN0b21zID0gcmVtb3RlLmN1c3RvbU11dGFzaGFiaWhhdCB8fCBbXTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSBuZXcgTWFwKGxvY2FsQ3VzdG9tcy5tYXAoYyA9PiBbYy5pZCwgY10pKTtcblxuICAgIHJlbW90ZUN1c3RvbXMuZm9yRWFjaChyYyA9PiB7XG4gICAgICBpZiAoIWN1c3RvbU1hcC5oYXMocmMuaWQpKSB7XG4gICAgICAgIGN1c3RvbU1hcC5zZXQocmMuaWQsIHJjKTtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWVyZ2VkLmN1c3RvbU11dGFzaGFiaWhhdCA9IEFycmF5LmZyb20oY3VzdG9tTWFwLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8vIFNpbXBsZSBcIkxhdGVzdCB3aW5zXCIgZm9yIHRoZSByZXN0XG4gIGNvbnN0IHJlbW90ZVRpbWUgPSByZW1vdGUuZXhwb3J0ZWRBdCB8fCAnJztcbiAgY29uc3QgbG9jYWxUaW1lID0gbG9jYWwuZXhwb3J0ZWRBdCB8fCAnJztcblxuICBpZiAocmVtb3RlVGltZSA+IGxvY2FsVGltZSkge1xuICAgIGlmIChKU09OLnN0cmluZ2lmeShyZW1vdGUubWluZG1hcHMpICE9PSBKU09OLnN0cmluZ2lmeShsb2NhbC5taW5kbWFwcykpIHtcbiAgICAgICAgbWVyZ2VkLm1pbmRtYXBzID0gcmVtb3RlLm1pbmRtYXBzO1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KHJlbW90ZS5wYXJ0TWluZG1hcHMpICE9PSBKU09OLnN0cmluZ2lmeShsb2NhbC5wYXJ0TWluZG1hcHMpKSB7XG4gICAgICAgIG1lcmdlZC5wYXJ0TWluZG1hcHMgPSByZW1vdGUucGFydE1pbmRtYXBzO1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KHJlbW90ZS5saXN0ZW5pbmdTdGF0cykgIT09IEpTT04uc3RyaW5naWZ5KGxvY2FsLmxpc3RlbmluZ1N0YXRzKSkge1xuICAgICAgICBtZXJnZWQubGlzdGVuaW5nU3RhdHMgPSByZW1vdGUubGlzdGVuaW5nU3RhdHM7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkocmVtb3RlLmxpc3RlbmluZ1Byb2dyZXNzKSAhPT0gSlNPTi5zdHJpbmdpZnkobG9jYWwubGlzdGVuaW5nUHJvZ3Jlc3MpKSB7XG4gICAgICAgIG1lcmdlZC5saXN0ZW5pbmdQcm9ncmVzcyA9IHJlbW90ZS5saXN0ZW5pbmdQcm9ncmVzcztcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChKU09OLnN0cmluZ2lmeShyZW1vdGUucmV2aWV3RXJyb3JzKSAhPT0gSlNPTi5zdHJpbmdpZnkobG9jYWwucmV2aWV3RXJyb3JzKSkge1xuICAgICAgICBtZXJnZWQucmV2aWV3RXJyb3JzID0gcmVtb3RlLnJldmlld0Vycm9ycztcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZW1vdGUuY3ljbGVTdGFydCAhPT0gbG9jYWwuY3ljbGVTdGFydCkge1xuICAgICAgICBtZXJnZWQuY3ljbGVTdGFydCA9IHJlbW90ZS5jeWNsZVN0YXJ0O1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlbW90ZS5saXN0ZW5pbmdDb21wbGV0ZSAhPT0gbG9jYWwubGlzdGVuaW5nQ29tcGxldGUpIHtcbiAgICAgICAgbWVyZ2VkLmxpc3RlbmluZ0NvbXBsZXRlID0gcmVtb3RlLmxpc3RlbmluZ0NvbXBsZXRlO1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBtZXJnZWQuZXhwb3J0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgXG4gIC8vIElmIHdlIGhhZCBjaGFuZ2VzIGZyb20gcmVtb3RlLCBvciB3ZSBhcmUgcHVzaGluZyBvdXIgbmV3ZXIgbG9jYWwgZGF0YVxuICByZXR1cm4geyBtZXJnZWREYXRhOiBtZXJnZWQsIGhhc0NoYW5nZXM6IGhhc0NoYW5nZXMgfHwgbG9jYWxUaW1lID4gcmVtb3RlVGltZSB9O1xufVxuIl0sIm5hbWVzIjpbImV4cG9ydEJhY2t1cCIsImltcG9ydEJhY2t1cCIsImZldGNoQmFja3VwRmlsZSIsInVwbG9hZEJhY2t1cEZpbGUiLCJzeW5jV2l0aENsb3VkIiwiYWNjZXNzVG9rZW4iLCJsb2NhbERhdGEiLCJkYXRhIiwicmVtb3RlRGF0YSIsImZpbGVJZCIsInN0YXR1cyIsIm1lc3NhZ2UiLCJtZXJnZWREYXRhIiwiaGFzQ2hhbmdlcyIsIm1lcmdlQmFja3VwcyIsInNldHRpbmdzIiwibGFzdFN5bmNlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZXJyb3IiLCJjb25zb2xlIiwibG9jYWwiLCJyZW1vdGUiLCJtZXJnZWQiLCJsb2NhbExlYXJuZWQiLCJsZWFybmVkVmVyc2VzIiwicmVtb3RlTGVhcm5lZCIsImFsbFN1cmFoSWRzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiT2JqZWN0Iiwia2V5cyIsIm1lcmdlZExlYXJuZWQiLCJpZCIsImNvbWJpbmVkIiwic29ydCIsImEiLCJiIiwiSlNPTiIsInN0cmluZ2lmeSIsImxvY2FsU2tpcHBlZCIsInNraXBwZWRTdXJhaHMiLCJyZW1vdGVTa2lwcGVkIiwiZm9yRWFjaCIsImhhcyIsImFkZCIsIm1lbW9yeU5vZGVzIiwibG9jYWxOb2RlcyIsInJlbW90ZU5vZGVzIiwibm9kZU1hcCIsIk1hcCIsIm1hcCIsIm4iLCJyTm9kZSIsImxOb2RlIiwiZ2V0Iiwic2NoZWR1bGVyIiwibGFzdFJldmlldyIsInNldCIsInZhbHVlcyIsIm11dGFzaGFiaWhhdERlY2lzaW9ucyIsImxvY2FsRGVjcyIsInJlbW90ZURlY3MiLCJhbGxLZXlzIiwibWVyZ2VkRGVjcyIsImtleSIsImwiLCJyIiwibFRpbWUiLCJjb25maXJtZWRBdCIsInJUaW1lIiwiY3VzdG9tTXV0YXNoYWJpaGF0IiwibG9jYWxDdXN0b21zIiwicmVtb3RlQ3VzdG9tcyIsImN1c3RvbU1hcCIsImMiLCJyYyIsInJlbW90ZVRpbWUiLCJleHBvcnRlZEF0IiwibG9jYWxUaW1lIiwibWluZG1hcHMiLCJwYXJ0TWluZG1hcHMiLCJsaXN0ZW5pbmdTdGF0cyIsImxpc3RlbmluZ1Byb2dyZXNzIiwicmV2aWV3RXJyb3JzIiwiY3ljbGVTdGFydCIsImxpc3RlbmluZ0NvbXBsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/sync.ts\n"));

/***/ })

});