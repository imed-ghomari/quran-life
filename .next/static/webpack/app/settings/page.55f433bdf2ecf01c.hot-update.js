"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/settings/page",{

/***/ "(app-pages-browser)/./src/lib/sync.ts":
/*!*************************!*\
  !*** ./src/lib/sync.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   syncWithCloud: function() { return /* binding */ syncWithCloud; }\n/* harmony export */ });\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _googleDrive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./googleDrive */ \"(app-pages-browser)/./src/lib/googleDrive.ts\");\n\n\n/**\n * Orchestrates the sync process:\n * 1. Pull remote data from Google Drive\n * 2. Merge with local data\n * 3. Push merged data back to Google Drive (if changed)\n */ async function syncWithCloud(accessToken) {\n    try {\n        const localData = (0,_storage__WEBPACK_IMPORTED_MODULE_0__.exportBackup)();\n        const { data: remoteData, fileId } = await (0,_googleDrive__WEBPACK_IMPORTED_MODULE_1__.fetchBackupFile)(accessToken);\n        if (!remoteData) {\n            // No remote data, push local data as the first backup\n            await (0,_googleDrive__WEBPACK_IMPORTED_MODULE_1__.uploadBackupFile)(accessToken, localData, null);\n            return {\n                status: \"success\",\n                message: \"Initial backup created on Google Drive\"\n            };\n        }\n        // Merge logic\n        const { mergedData, hasChanges } = mergeBackups(localData, remoteData);\n        if (hasChanges) {\n            // Update local storage\n            mergedData.settings = {\n                ...mergedData.settings || {},\n                lastSyncedAt: new Date().toISOString()\n            };\n            (0,_storage__WEBPACK_IMPORTED_MODULE_0__.importBackup)(mergedData);\n            // Update remote storage\n            await (0,_googleDrive__WEBPACK_IMPORTED_MODULE_1__.uploadBackupFile)(accessToken, mergedData, fileId);\n            return {\n                status: \"success\",\n                message: \"Sync complete: data merged\"\n            };\n        }\n        // Even if no data changed, update the sync timestamp locally\n        const settings = localData.settings || {};\n        settings.lastSyncedAt = new Date().toISOString();\n        (0,_storage__WEBPACK_IMPORTED_MODULE_0__.importBackup)({\n            ...localData,\n            settings\n        });\n        return {\n            status: \"no_change\",\n            message: \"Already in sync\"\n        };\n    } catch (error) {\n        console.error(\"Sync failed:\", error);\n        return {\n            status: \"error\",\n            message: error.message || \"Unknown sync error\"\n        };\n    }\n}\n/**\n * Merges local and remote backups.\n * Simple strategy: \n * - For sets/dictionaries: Union of keys/values\n * - For single values: Latest date wins\n */ function mergeBackups(local, remote) {\n    const merged = {\n        ...local\n    };\n    let hasChanges = false;\n    // 1. Settings (Learned Verses & Skipped Surahs)\n    if (remote.settings) {\n        var _local_settings, _remote_settings, _local_settings1, _remote_settings1;\n        // Merge learnedVerses (Union)\n        const localLearned = ((_local_settings = local.settings) === null || _local_settings === void 0 ? void 0 : _local_settings.learnedVerses) || {};\n        const remoteLearned = ((_remote_settings = remote.settings) === null || _remote_settings === void 0 ? void 0 : _remote_settings.learnedVerses) || {};\n        const allSurahIds = Array.from(new Set([\n            ...Object.keys(localLearned),\n            ...Object.keys(remoteLearned)\n        ]));\n        const mergedLearned = {};\n        for (const id of allSurahIds){\n            const combined = new Set([\n                ...localLearned[id] || [],\n                ...remoteLearned[id] || []\n            ]);\n            mergedLearned[id] = Array.from(combined).sort((a, b)=>a - b);\n            if (JSON.stringify(mergedLearned[id]) !== JSON.stringify(localLearned[id])) {\n                hasChanges = true;\n            }\n        }\n        // Merge skippedSurahs (Union)\n        const localSkipped = new Set(((_local_settings1 = local.settings) === null || _local_settings1 === void 0 ? void 0 : _local_settings1.skippedSurahs) || []);\n        const remoteSkipped = ((_remote_settings1 = remote.settings) === null || _remote_settings1 === void 0 ? void 0 : _remote_settings1.skippedSurahs) || [];\n        remoteSkipped.forEach((id)=>{\n            if (!localSkipped.has(id)) {\n                localSkipped.add(id);\n                hasChanges = true;\n            }\n        });\n        merged.settings = {\n            ...local.settings,\n            learnedVerses: mergedLearned,\n            skippedSurahs: Array.from(localSkipped).sort((a, b)=>a - b)\n        };\n    }\n    // 2. Memory Nodes (Latest SM-2 state wins per node ID)\n    if (remote.memoryNodes) {\n        const localNodes = local.memoryNodes || [];\n        const remoteNodes = remote.memoryNodes || [];\n        const nodeMap = new Map(localNodes.map((n)=>[\n                n.id,\n                n\n            ]));\n        remoteNodes.forEach((rNode)=>{\n            const lNode = nodeMap.get(rNode.id);\n            if (!lNode || rNode.scheduler.lastReview > lNode.scheduler.lastReview) {\n                nodeMap.set(rNode.id, rNode);\n                hasChanges = true;\n            }\n        });\n        merged.memoryNodes = Array.from(nodeMap.values());\n    }\n    // 3. Mutashabihat Decisions (Latest confirmedAt wins)\n    if (remote.mutashabihatDecisions) {\n        const localDecs = local.mutashabihatDecisions || {};\n        const remoteDecs = remote.mutashabihatDecisions || {};\n        const allKeys = Array.from(new Set([\n            ...Object.keys(localDecs),\n            ...Object.keys(remoteDecs)\n        ]));\n        const mergedDecs = {};\n        for (const key of allKeys){\n            const l = localDecs[key];\n            const r = remoteDecs[key];\n            if (!l) {\n                mergedDecs[key] = r;\n                hasChanges = true;\n            } else if (!r) {\n                mergedDecs[key] = l;\n            } else {\n                const lTime = l.confirmedAt || \"\";\n                const rTime = r.confirmedAt || \"\";\n                if (rTime > lTime) {\n                    mergedDecs[key] = r;\n                    hasChanges = true;\n                } else {\n                    mergedDecs[key] = l;\n                }\n            }\n        }\n        merged.mutashabihatDecisions = mergedDecs;\n    }\n    // 4. Custom Mutashabihat (Union by ID)\n    if (remote.customMutashabihat) {\n        const localCustoms = local.customMutashabihat || [];\n        const remoteCustoms = remote.customMutashabihat || [];\n        const customMap = new Map(localCustoms.map((c)=>[\n                c.id,\n                c\n            ]));\n        remoteCustoms.forEach((rc)=>{\n            if (!customMap.has(rc.id)) {\n                customMap.set(rc.id, rc);\n                hasChanges = true;\n            }\n        });\n        merged.customMutashabihat = Array.from(customMap.values());\n    }\n    // Simple \"Latest wins\" for the rest\n    const remoteTime = remote.exportedAt || \"\";\n    const localTime = local.exportedAt || \"\";\n    if (remoteTime > localTime) {\n        if (JSON.stringify(remote.mindmaps) !== JSON.stringify(local.mindmaps)) {\n            merged.mindmaps = remote.mindmaps;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.partMindmaps) !== JSON.stringify(local.partMindmaps)) {\n            merged.partMindmaps = remote.partMindmaps;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.listeningStats) !== JSON.stringify(local.listeningStats)) {\n            merged.listeningStats = remote.listeningStats;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.listeningProgress) !== JSON.stringify(local.listeningProgress)) {\n            merged.listeningProgress = remote.listeningProgress;\n            hasChanges = true;\n        }\n        if (JSON.stringify(remote.reviewErrors) !== JSON.stringify(local.reviewErrors)) {\n            merged.reviewErrors = remote.reviewErrors;\n            hasChanges = true;\n        }\n        if (remote.cycleStart !== local.cycleStart) {\n            merged.cycleStart = remote.cycleStart;\n            hasChanges = true;\n        }\n        if (remote.listeningComplete !== local.listeningComplete) {\n            merged.listeningComplete = remote.listeningComplete;\n            hasChanges = true;\n        }\n    }\n    merged.exportedAt = new Date().toISOString();\n    // If we had changes from remote, or we are pushing our newer local data\n    return {\n        mergedData: merged,\n        hasChanges: hasChanges || localTime > remoteTime\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUI7WUFDbkR2RSxhQUFhO1FBQ2pCO1FBQ0EsSUFBSTBCLEtBQUtDLFNBQVMsQ0FBQ2xCLE9BQU8rRCxZQUFZLE1BQU05QyxLQUFLQyxTQUFTLENBQUNuQixNQUFNZ0UsWUFBWSxHQUFHO1lBQzVFOUQsT0FBTzhELFlBQVksR0FBRy9ELE9BQU8rRCxZQUFZO1lBQ3pDeEUsYUFBYTtRQUNqQjtRQUNBLElBQUlTLE9BQU9nRSxVQUFVLEtBQUtqRSxNQUFNaUUsVUFBVSxFQUFFO1lBQ3hDL0QsT0FBTytELFVBQVUsR0FBR2hFLE9BQU9nRSxVQUFVO1lBQ3JDekUsYUFBYTtRQUNqQjtRQUNBLElBQUlTLE9BQU9pRSxpQkFBaUIsS0FBS2xFLE1BQU1rRSxpQkFBaUIsRUFBRTtZQUN0RGhFLE9BQU9nRSxpQkFBaUIsR0FBR2pFLE9BQU9pRSxpQkFBaUI7WUFDbkQxRSxhQUFhO1FBQ2pCO0lBQ0Y7SUFFQVUsT0FBT3dELFVBQVUsR0FBRyxJQUFJOUQsT0FBT0MsV0FBVztJQUUxQyx3RUFBd0U7SUFDeEUsT0FBTztRQUFFTixZQUFZVztRQUFRVixZQUFZQSxjQUFjbUUsWUFBWUY7SUFBVztBQUNoRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3N5bmMudHM/NzU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEJhY2t1cERhdGEsIGV4cG9ydEJhY2t1cCwgaW1wb3J0QmFja3VwIH0gZnJvbSAnLi9zdG9yYWdlJztcbmltcG9ydCB7IGZldGNoQmFja3VwRmlsZSwgdXBsb2FkQmFja3VwRmlsZSB9IGZyb20gJy4vZ29vZ2xlRHJpdmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNSZXN1bHQge1xuICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdub19jaGFuZ2UnIHwgJ2Vycm9yJztcbiAgbWVzc2FnZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBPcmNoZXN0cmF0ZXMgdGhlIHN5bmMgcHJvY2VzczpcbiAqIDEuIFB1bGwgcmVtb3RlIGRhdGEgZnJvbSBHb29nbGUgRHJpdmVcbiAqIDIuIE1lcmdlIHdpdGggbG9jYWwgZGF0YVxuICogMy4gUHVzaCBtZXJnZWQgZGF0YSBiYWNrIHRvIEdvb2dsZSBEcml2ZSAoaWYgY2hhbmdlZClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN5bmNXaXRoQ2xvdWQoYWNjZXNzVG9rZW46IHN0cmluZyk6IFByb21pc2U8U3luY1Jlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGxvY2FsRGF0YSA9IGV4cG9ydEJhY2t1cCgpO1xuICAgIGNvbnN0IHsgZGF0YTogcmVtb3RlRGF0YSwgZmlsZUlkIH0gPSBhd2FpdCBmZXRjaEJhY2t1cEZpbGUoYWNjZXNzVG9rZW4pO1xuXG4gICAgaWYgKCFyZW1vdGVEYXRhKSB7XG4gICAgICAvLyBObyByZW1vdGUgZGF0YSwgcHVzaCBsb2NhbCBkYXRhIGFzIHRoZSBmaXJzdCBiYWNrdXBcbiAgICAgIGF3YWl0IHVwbG9hZEJhY2t1cEZpbGUoYWNjZXNzVG9rZW4sIGxvY2FsRGF0YSwgbnVsbCk7XG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJywgbWVzc2FnZTogJ0luaXRpYWwgYmFja3VwIGNyZWF0ZWQgb24gR29vZ2xlIERyaXZlJyB9O1xuICAgIH1cblxuICAgIC8vIE1lcmdlIGxvZ2ljXG4gICAgY29uc3QgeyBtZXJnZWREYXRhLCBoYXNDaGFuZ2VzIH0gPSBtZXJnZUJhY2t1cHMobG9jYWxEYXRhLCByZW1vdGVEYXRhKTtcblxuICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RvcmFnZVxuICAgICAgbWVyZ2VkRGF0YS5zZXR0aW5ncyA9IHtcbiAgICAgICAgLi4uKG1lcmdlZERhdGEuc2V0dGluZ3MgfHwge30pLFxuICAgICAgICBsYXN0U3luY2VkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSBhcyBhbnk7XG4gICAgICBcbiAgICAgIGltcG9ydEJhY2t1cChtZXJnZWREYXRhKTtcbiAgICAgIC8vIFVwZGF0ZSByZW1vdGUgc3RvcmFnZVxuICAgICAgYXdhaXQgdXBsb2FkQmFja3VwRmlsZShhY2Nlc3NUb2tlbiwgbWVyZ2VkRGF0YSwgZmlsZUlkKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnLCBtZXNzYWdlOiAnU3luYyBjb21wbGV0ZTogZGF0YSBtZXJnZWQnIH07XG4gICAgfVxuXG4gICAgLy8gRXZlbiBpZiBubyBkYXRhIGNoYW5nZWQsIHVwZGF0ZSB0aGUgc3luYyB0aW1lc3RhbXAgbG9jYWxseVxuICAgIGNvbnN0IHNldHRpbmdzID0gbG9jYWxEYXRhLnNldHRpbmdzIHx8IHt9O1xuICAgIHNldHRpbmdzLmxhc3RTeW5jZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBpbXBvcnRCYWNrdXAoeyAuLi5sb2NhbERhdGEsIHNldHRpbmdzIH0gYXMgYW55KTtcblxuICAgIHJldHVybiB7IHN0YXR1czogJ25vX2NoYW5nZScsIG1lc3NhZ2U6ICdBbHJlYWR5IGluIHN5bmMnIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTeW5jIGZhaWxlZDonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIHN5bmMgZXJyb3InIH07XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZXMgbG9jYWwgYW5kIHJlbW90ZSBiYWNrdXBzLlxuICogU2ltcGxlIHN0cmF0ZWd5OiBcbiAqIC0gRm9yIHNldHMvZGljdGlvbmFyaWVzOiBVbmlvbiBvZiBrZXlzL3ZhbHVlc1xuICogLSBGb3Igc2luZ2xlIHZhbHVlczogTGF0ZXN0IGRhdGUgd2luc1xuICovXG5mdW5jdGlvbiBtZXJnZUJhY2t1cHMobG9jYWw6IEJhY2t1cERhdGEsIHJlbW90ZTogQmFja3VwRGF0YSk6IHsgbWVyZ2VkRGF0YTogQmFja3VwRGF0YTsgaGFzQ2hhbmdlczogYm9vbGVhbiB9IHtcbiAgY29uc3QgbWVyZ2VkOiBCYWNrdXBEYXRhID0geyAuLi5sb2NhbCB9O1xuICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuXG4gIC8vIDEuIFNldHRpbmdzIChMZWFybmVkIFZlcnNlcyAmIFNraXBwZWQgU3VyYWhzKVxuICBpZiAocmVtb3RlLnNldHRpbmdzKSB7XG4gICAgLy8gTWVyZ2UgbGVhcm5lZFZlcnNlcyAoVW5pb24pXG4gICAgY29uc3QgbG9jYWxMZWFybmVkID0gbG9jYWwuc2V0dGluZ3M/LmxlYXJuZWRWZXJzZXMgfHwge307XG4gICAgY29uc3QgcmVtb3RlTGVhcm5lZCA9IHJlbW90ZS5zZXR0aW5ncz8ubGVhcm5lZFZlcnNlcyB8fCB7fTtcbiAgICBjb25zdCBhbGxTdXJhaElkcyA9IEFycmF5LmZyb20obmV3IFNldChbLi4uT2JqZWN0LmtleXMobG9jYWxMZWFybmVkKSwgLi4uT2JqZWN0LmtleXMocmVtb3RlTGVhcm5lZCldKSk7XG4gICAgXG4gICAgY29uc3QgbWVyZ2VkTGVhcm5lZDogUmVjb3JkPHN0cmluZywgbnVtYmVyW10+ID0ge307XG4gICAgZm9yIChjb25zdCBpZCBvZiBhbGxTdXJhaElkcykge1xuICAgICAgY29uc3QgY29tYmluZWQgPSBuZXcgU2V0KFsuLi4obG9jYWxMZWFybmVkW2lkXSB8fCBbXSksIC4uLihyZW1vdGVMZWFybmVkW2lkXSB8fCBbXSldKTtcbiAgICAgIG1lcmdlZExlYXJuZWRbaWRdID0gQXJyYXkuZnJvbShjb21iaW5lZCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KG1lcmdlZExlYXJuZWRbaWRdKSAhPT0gSlNPTi5zdHJpbmdpZnkobG9jYWxMZWFybmVkW2lkXSkpIHtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIE1lcmdlIHNraXBwZWRTdXJhaHMgKFVuaW9uKVxuICAgIGNvbnN0IGxvY2FsU2tpcHBlZCA9IG5ldyBTZXQobG9jYWwuc2V0dGluZ3M/LnNraXBwZWRTdXJhaHMgfHwgW10pO1xuICAgIGNvbnN0IHJlbW90ZVNraXBwZWQgPSByZW1vdGUuc2V0dGluZ3M/LnNraXBwZWRTdXJhaHMgfHwgW107XG4gICAgcmVtb3RlU2tpcHBlZC5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGlmICghbG9jYWxTa2lwcGVkLmhhcyhpZCkpIHtcbiAgICAgICAgbG9jYWxTa2lwcGVkLmFkZChpZCk7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWVyZ2VkLnNldHRpbmdzID0ge1xuICAgICAgLi4ubG9jYWwuc2V0dGluZ3MhLFxuICAgICAgbGVhcm5lZFZlcnNlczogbWVyZ2VkTGVhcm5lZCxcbiAgICAgIHNraXBwZWRTdXJhaHM6IEFycmF5LmZyb20obG9jYWxTa2lwcGVkKS5zb3J0KChhLCBiKSA9PiBhIC0gYiksXG4gICAgfTtcbiAgfVxuXG4gIC8vIDIuIE1lbW9yeSBOb2RlcyAoTGF0ZXN0IFNNLTIgc3RhdGUgd2lucyBwZXIgbm9kZSBJRClcbiAgaWYgKHJlbW90ZS5tZW1vcnlOb2Rlcykge1xuICAgIGNvbnN0IGxvY2FsTm9kZXMgPSBsb2NhbC5tZW1vcnlOb2RlcyB8fCBbXTtcbiAgICBjb25zdCByZW1vdGVOb2RlcyA9IHJlbW90ZS5tZW1vcnlOb2RlcyB8fCBbXTtcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcChsb2NhbE5vZGVzLm1hcChuID0+IFtuLmlkLCBuXSkpO1xuXG4gICAgcmVtb3RlTm9kZXMuZm9yRWFjaChyTm9kZSA9PiB7XG4gICAgICBjb25zdCBsTm9kZSA9IG5vZGVNYXAuZ2V0KHJOb2RlLmlkKTtcbiAgICAgIGlmICghbE5vZGUgfHwgck5vZGUuc2NoZWR1bGVyLmxhc3RSZXZpZXcgPiBsTm9kZS5zY2hlZHVsZXIubGFzdFJldmlldykge1xuICAgICAgICBub2RlTWFwLnNldChyTm9kZS5pZCwgck5vZGUpO1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXJnZWQubWVtb3J5Tm9kZXMgPSBBcnJheS5mcm9tKG5vZGVNYXAudmFsdWVzKCkpO1xuICB9XG5cbiAgLy8gMy4gTXV0YXNoYWJpaGF0IERlY2lzaW9ucyAoTGF0ZXN0IGNvbmZpcm1lZEF0IHdpbnMpXG4gIGlmIChyZW1vdGUubXV0YXNoYWJpaGF0RGVjaXNpb25zKSB7XG4gICAgY29uc3QgbG9jYWxEZWNzID0gbG9jYWwubXV0YXNoYWJpaGF0RGVjaXNpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlbW90ZURlY3MgPSByZW1vdGUubXV0YXNoYWJpaGF0RGVjaXNpb25zIHx8IHt9O1xuICAgIGNvbnN0IGFsbEtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGxvY2FsRGVjcyksIC4uLk9iamVjdC5rZXlzKHJlbW90ZURlY3MpXSkpO1xuXG4gICAgY29uc3QgbWVyZ2VkRGVjczogdHlwZW9mIGxvY2FsRGVjcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcbiAgICAgIGNvbnN0IGwgPSBsb2NhbERlY3Nba2V5XTtcbiAgICAgIGNvbnN0IHIgPSByZW1vdGVEZWNzW2tleV07XG4gICAgICBpZiAoIWwpIHtcbiAgICAgICAgbWVyZ2VkRGVjc1trZXldID0gcjtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFyKSB7XG4gICAgICAgIG1lcmdlZERlY3Nba2V5XSA9IGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsVGltZSA9IGwuY29uZmlybWVkQXQgfHwgJyc7XG4gICAgICAgIGNvbnN0IHJUaW1lID0gci5jb25maXJtZWRBdCB8fCAnJztcbiAgICAgICAgaWYgKHJUaW1lID4gbFRpbWUpIHtcbiAgICAgICAgICBtZXJnZWREZWNzW2tleV0gPSByO1xuICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlZERlY3Nba2V5XSA9IGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VkLm11dGFzaGFiaWhhdERlY2lzaW9ucyA9IG1lcmdlZERlY3M7XG4gIH1cblxuICAvLyA0LiBDdXN0b20gTXV0YXNoYWJpaGF0IChVbmlvbiBieSBJRClcbiAgaWYgKHJlbW90ZS5jdXN0b21NdXRhc2hhYmloYXQpIHtcbiAgICBjb25zdCBsb2NhbEN1c3RvbXMgPSBsb2NhbC5jdXN0b21NdXRhc2hhYmloYXQgfHwgW107XG4gICAgY29uc3QgcmVtb3RlQ3VzdG9tcyA9IHJlbW90ZS5jdXN0b21NdXRhc2hhYmloYXQgfHwgW107XG4gICAgY29uc3QgY3VzdG9tTWFwID0gbmV3IE1hcChsb2NhbEN1c3RvbXMubWFwKGMgPT4gW2MuaWQsIGNdKSk7XG5cbiAgICByZW1vdGVDdXN0b21zLmZvckVhY2gocmMgPT4ge1xuICAgICAgaWYgKCFjdXN0b21NYXAuaGFzKHJjLmlkKSkge1xuICAgICAgICBjdXN0b21NYXAuc2V0KHJjLmlkLCByYyk7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lcmdlZC5jdXN0b21NdXRhc2hhYmloYXQgPSBBcnJheS5mcm9tKGN1c3RvbU1hcC52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyBTaW1wbGUgXCJMYXRlc3Qgd2luc1wiIGZvciB0aGUgcmVzdFxuICBjb25zdCByZW1vdGVUaW1lID0gcmVtb3RlLmV4cG9ydGVkQXQgfHwgJyc7XG4gIGNvbnN0IGxvY2FsVGltZSA9IGxvY2FsLmV4cG9ydGVkQXQgfHwgJyc7XG5cbiAgaWYgKHJlbW90ZVRpbWUgPiBsb2NhbFRpbWUpIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkocmVtb3RlLm1pbmRtYXBzKSAhPT0gSlNPTi5zdHJpbmdpZnkobG9jYWwubWluZG1hcHMpKSB7XG4gICAgICAgIG1lcmdlZC5taW5kbWFwcyA9IHJlbW90ZS5taW5kbWFwcztcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChKU09OLnN0cmluZ2lmeShyZW1vdGUucGFydE1pbmRtYXBzKSAhPT0gSlNPTi5zdHJpbmdpZnkobG9jYWwucGFydE1pbmRtYXBzKSkge1xuICAgICAgICBtZXJnZWQucGFydE1pbmRtYXBzID0gcmVtb3RlLnBhcnRNaW5kbWFwcztcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChKU09OLnN0cmluZ2lmeShyZW1vdGUubGlzdGVuaW5nU3RhdHMpICE9PSBKU09OLnN0cmluZ2lmeShsb2NhbC5saXN0ZW5pbmdTdGF0cykpIHtcbiAgICAgICAgbWVyZ2VkLmxpc3RlbmluZ1N0YXRzID0gcmVtb3RlLmxpc3RlbmluZ1N0YXRzO1xuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KHJlbW90ZS5saXN0ZW5pbmdQcm9ncmVzcykgIT09IEpTT04uc3RyaW5naWZ5KGxvY2FsLmxpc3RlbmluZ1Byb2dyZXNzKSkge1xuICAgICAgICBtZXJnZWQubGlzdGVuaW5nUHJvZ3Jlc3MgPSByZW1vdGUubGlzdGVuaW5nUHJvZ3Jlc3M7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkocmVtb3RlLnJldmlld0Vycm9ycykgIT09IEpTT04uc3RyaW5naWZ5KGxvY2FsLnJldmlld0Vycm9ycykpIHtcbiAgICAgICAgbWVyZ2VkLnJldmlld0Vycm9ycyA9IHJlbW90ZS5yZXZpZXdFcnJvcnM7XG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVtb3RlLmN5Y2xlU3RhcnQgIT09IGxvY2FsLmN5Y2xlU3RhcnQpIHtcbiAgICAgICAgbWVyZ2VkLmN5Y2xlU3RhcnQgPSByZW1vdGUuY3ljbGVTdGFydDtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZW1vdGUubGlzdGVuaW5nQ29tcGxldGUgIT09IGxvY2FsLmxpc3RlbmluZ0NvbXBsZXRlKSB7XG4gICAgICAgIG1lcmdlZC5saXN0ZW5pbmdDb21wbGV0ZSA9IHJlbW90ZS5saXN0ZW5pbmdDb21wbGV0ZTtcbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgbWVyZ2VkLmV4cG9ydGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIFxuICAvLyBJZiB3ZSBoYWQgY2hhbmdlcyBmcm9tIHJlbW90ZSwgb3Igd2UgYXJlIHB1c2hpbmcgb3VyIG5ld2VyIGxvY2FsIGRhdGFcbiAgcmV0dXJuIHsgbWVyZ2VkRGF0YTogbWVyZ2VkLCBoYXNDaGFuZ2VzOiBoYXNDaGFuZ2VzIHx8IGxvY2FsVGltZSA+IHJlbW90ZVRpbWUgfTtcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRCYWNrdXAiLCJpbXBvcnRCYWNrdXAiLCJmZXRjaEJhY2t1cEZpbGUiLCJ1cGxvYWRCYWNrdXBGaWxlIiwic3luY1dpdGhDbG91ZCIsImFjY2Vzc1Rva2VuIiwibG9jYWxEYXRhIiwiZGF0YSIsInJlbW90ZURhdGEiLCJmaWxlSWQiLCJzdGF0dXMiLCJtZXNzYWdlIiwibWVyZ2VkRGF0YSIsImhhc0NoYW5nZXMiLCJtZXJnZUJhY2t1cHMiLCJzZXR0aW5ncyIsImxhc3RTeW5jZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVycm9yIiwiY29uc29sZSIsImxvY2FsIiwicmVtb3RlIiwibWVyZ2VkIiwibG9jYWxMZWFybmVkIiwibGVhcm5lZFZlcnNlcyIsInJlbW90ZUxlYXJuZWQiLCJhbGxTdXJhaElkcyIsIkFycmF5IiwiZnJvbSIsIlNldCIsIk9iamVjdCIsImtleXMiLCJtZXJnZWRMZWFybmVkIiwiaWQiLCJjb21iaW5lZCIsInNvcnQiLCJhIiwiYiIsIkpTT04iLCJzdHJpbmdpZnkiLCJsb2NhbFNraXBwZWQiLCJza2lwcGVkU3VyYWhzIiwicmVtb3RlU2tpcHBlZCIsImZvckVhY2giLCJoYXMiLCJhZGQiLCJtZW1vcnlOb2RlcyIsImxvY2FsTm9kZXMiLCJyZW1vdGVOb2RlcyIsIm5vZGVNYXAiLCJNYXAiLCJtYXAiLCJuIiwick5vZGUiLCJsTm9kZSIsImdldCIsInNjaGVkdWxlciIsImxhc3RSZXZpZXciLCJzZXQiLCJ2YWx1ZXMiLCJtdXRhc2hhYmloYXREZWNpc2lvbnMiLCJsb2NhbERlY3MiLCJyZW1vdGVEZWNzIiwiYWxsS2V5cyIsIm1lcmdlZERlY3MiLCJrZXkiLCJsIiwiciIsImxUaW1lIiwiY29uZmlybWVkQXQiLCJyVGltZSIsImN1c3RvbU11dGFzaGFiaWhhdCIsImxvY2FsQ3VzdG9tcyIsInJlbW90ZUN1c3RvbXMiLCJjdXN0b21NYXAiLCJjIiwicmMiLCJyZW1vdGVUaW1lIiwiZXhwb3J0ZWRBdCIsImxvY2FsVGltZSIsIm1pbmRtYXBzIiwicGFydE1pbmRtYXBzIiwibGlzdGVuaW5nU3RhdHMiLCJsaXN0ZW5pbmdQcm9ncmVzcyIsInJldmlld0Vycm9ycyIsImN5Y2xlU3RhcnQiLCJsaXN0ZW5pbmdDb21wbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/sync.ts\n"));

/***/ })

});